<!-- Strategic Dominion: Cyprus Wars - v1.13.0 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategic Dominion: Cyprus Wars</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-dark: #242933;
            --text-main: #eceff4;
            --text-gold: #ebcb8b;
            --ocean-deep: #2e3440;
            --ocean-coast: #4c566a;
            --land: #a3be8c;
            --mountain: #434c5e;
            --glass-bg: rgba(0, 0, 0, 0.6);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Lato', sans-serif;
            color: var(--text-main);
            user-select: none;
        }

        h1, h2, h3, .medieval-font {
            font-family: 'Cinzel', serif;
        }

        /* Views */
        .view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
        }
        
        .view.active {
            display: flex;
        }

        /* Menu View */
        #menu-view {
            background: radial-gradient(circle at 50% 50%, #2e3440 0%, #1a1e26 100%);
            align-items: center;
            justify-content: center;
        }

        .menu-card {
            background: rgba(30, 35, 45, 0.9);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 16px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            max-width: 800px; 
            width: 90%;
            text-align: center;
        }

        .title-gradient {
            background: linear-gradient(to right, #ebcb8b, #d08770);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 3rem;
            margin: 0 0 10px 0;
        }

        input, select {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #4c566a;
            color: white;
            padding: 10px;
            border-radius: 8px;
            width: 100%;
            margin-bottom: 15px;
            box-sizing: border-box;
            font-family: 'Lato', sans-serif;
        }

        button {
            background: linear-gradient(135deg, #5e81ac, #81a1c1);
            border: none;
            padding: 12px 24px;
            color: white;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            font-family: 'Cinzel', serif;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(94, 129, 172, 0.5);
        }
        
        button:disabled {
            background: #4c566a;
            cursor: not-allowed;
            opacity: 0.7;
        }

        button.secondary {
            background: #434c5e;
        }
        
        button.danger {
            background: #bf616a;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            text-align: left;
        }

        /* Lobby View */
        #lobby-view {
            background: #242933;
            align-items: center;
            justify-content: center;
        }
        
        .player-list {
            margin: 20px 0;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
        }

        .player-item {
            display: grid;
            grid-template-columns: 40px 2fr 1fr 1fr 40px;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-bottom: 1px solid #4c566a;
            text-align: left;
        }
        
        .player-item select {
            margin-bottom: 0;
            padding: 5px;
        }

        /* Game View */
        #game-view {
            position: relative;
        }

        canvas {
            display: block;
            background: #1a1e26;
        }

        /* HUD */
        #hud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
        }

        .hud-panel {
            position: absolute;
            background: var(--glass-bg);
            backdrop-filter: blur(5px);
            border: 1px solid var(--glass-border);
            padding: 10px;
            pointer-events: auto;
            border-radius: 8px;
        }

        #top-bar {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        #top-right {
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
        }

        #bottom-left {
            bottom: 10px;
            left: 10px;
            width: 300px;
            height: 200px;
            overflow-y: auto;
            font-size: 0.9rem;
        }

        #bottom-right {
            bottom: 10px;
            right: 10px;
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 2px;
        }

        .action-btn {
            width: 100%;
            margin-bottom: 5px;
            font-size: 0.8rem;
            padding: 8px;
        }

        .resource-display {
            color: var(--text-gold);
            font-weight: bold;
        }

        .modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: auto;
        }
        
        .hidden { display: none !important; }

        .tech-col { flex: 1; padding: 0 10px; }
        .tech-tree-node {
            padding: 10px;
            border: 1px solid #88c0d0;
            margin: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .tech-tree-node:hover { background: rgba(136, 192, 208, 0.2); }
        .tech-tree-node.unlocked { background: #a3be8c; color: #2e3440; border-color: #8fbcbb; cursor: default; }
        .tech-tree-node.locked { background: #2e3440; color: #666; }

        #loading-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            flex-direction: column;
        }
        
        /* Turn Notification */
        #turn-notification {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-family: 'Cinzel', serif;
            color: #ebcb8b;
            text-shadow: 0 0 20px rgba(0,0,0,0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
            z-index: 50;
        }
        #turn-notification.show {
            opacity: 1;
        }
        
        .unit-stats { font-size: 0.8em; color: #bbb; }
        
        /* Diplomacy */
        .diplomacy-item {
            padding: 10px;
            background: rgba(255,255,255,0.05);
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
    </style>
</head>
<body>

<!-- Loading / Peer Init -->
<div id="loading-overlay">
    <h2 class="medieval-font">Initializing Comms...</h2>
    <div id="init-status">Connecting to Network...</div>
</div>

<!-- Turn Notification -->
<div id="turn-notification">YOUR TURN</div>

<!-- Menu View -->
<div id="menu-view" class="view active">
    <div class="menu-card">
        <h1 class="title-gradient medieval-font">Strategic Dominion</h1>
        <h2 style="color: #88c0d0; letter-spacing: 4px; margin-bottom: 30px;">CYPRUS WARS</h2>
        
        <div class="grid-2">
            <div style="border-right: 1px solid #4c566a; padding-right: 20px;">
                <h3 class="medieval-font">Profile</h3>
                <label>Name</label>
                <input type="text" id="player-name" value="Commander">
                <br><br>
                <button id="resume-btn" class="hidden" onclick="gameApp.loadFromLocal()" style="background: #ebcb8b; color: #2e3440;">RESUME CAMPAIGN</button>
                <input type="file" id="save-upload" accept=".json" onchange="gameApp.loadGame(this)" style="display:none;">
                <button onclick="document.getElementById('save-upload').click()" class="secondary" style="margin-top: 10px; font-size: 0.8rem;">Load Save File</button>
            </div>
            
            <div style="display: flex; flex-direction: column; justify-content: center;">
                <button onclick="gameApp.hostGame()">Create Campaign</button>
                <div style="margin: 15px 0; font-size: 0.8rem; color: #888;">- OR -</div>
                <input type="text" id="host-id-input" placeholder="Enter Host ID">
                <button class="secondary" onclick="gameApp.joinGame()">Join Campaign</button>
            </div>
        </div>
        
        <div style="margin-top: 20px; font-size: 0.8rem; color: #666;">
            Your ID: <span id="my-peer-id" style="color: #88c0d0; user-select: all;">...</span>
        </div>
    </div>
</div>

<!-- Lobby View -->
<div id="lobby-view" class="view">
    <div class="menu-card">
        <h2 class="medieval-font">Mission Lobby</h2>
        <div class="player-list" id="lobby-slots"></div>
        <div id="host-controls" class="hidden">
            <button onclick="gameApp.addSlot()" style="margin-bottom: 10px; font-size: 0.8rem;">+ Add AI / Slot</button>
            <h3 class="medieval-font">Map Settings</h3>
            <select id="map-type">
                <option value="CYPRUS">Cyprus (Large Historic)</option>
                <option value="RANDOM">Archipelago (Random)</option>
                <option value="SIMPLE_SQUARE">Simple Square (Test)</option>
            </select>
            <br><br>
            <button onclick="gameApp.startGame()">Deploy Units</button>
        </div>
        <div id="client-controls" class="hidden">
            <p>Waiting for Host to Start...</p>
        </div>
        <br>
        <button class="secondary" onclick="gameApp.leaveLobby()">Back</button>
    </div>
</div>

<!-- Game View -->
<div id="game-view" class="view">
    <canvas id="game-canvas"></canvas>
    
    <div id="hud-layer">
        <!-- Top Bar -->
        <div id="top-bar" class="hud-panel">
            <div class="medieval-font" id="turn-indicator">Turn 1</div>
            <div id="timer" style="color: #d08770; font-weight: bold;">45s</div>
            <div>Gold: <span id="gold-display" class="resource-display">0</span></div>
            <div>Income: <span id="income-display" class="resource-display">+0</span></div>
        </div>
        
        <div id="top-right" class="hud-panel" style="background: transparent; border: none; padding:0; top: 10px; right: 10px; pointer-events: auto;">
             <button onclick="gameApp.toggleSystemMenu()" style="font-size: 1.2rem; padding: 5px 10px;">‚öôÔ∏è</button>
        </div>

        <!-- Log -->
        <div id="bottom-left" class="hud-panel">
            <div id="game-log"></div>
        </div>

        <!-- Controls -->
        <div id="bottom-right" class="hud-panel">
            <div id="selection-panel">
                <h3 class="medieval-font" id="selection-title" style="margin: 0 0 10px 0;">No Selection</h3>
                <div id="selection-details" style="font-size: 0.8rem; margin-bottom: 10px;"></div>
                <div id="action-buttons"></div>
            </div>
            <div id="turn-controls" style="border-top: 1px solid #666; margin-top: 5px; padding-top: 5px;">
                <button class="action-btn" onclick="gameApp.toggleDiplomacy()">Diplomacy</button>
                <button class="action-btn" onclick="gameApp.toggleTechTree()">Research</button>
                <button class="action-btn" style="background: #bf616a;" onclick="gameApp.endTurn()">End Turn</button>
            </div>
        </div>
    </div>

    <!-- Tech Tree Modal -->
    <div id="tech-modal" class="modal hidden">
        <div class="menu-card" style="max-width: 800px;">
            <h2 class="medieval-font">Technology Research</h2>
            <div style="display: flex; justify-content: space-between;">
                <div class="tech-col">
                    <h3 style="color:#ebcb8b">Army</h3>
                    <div id="tech-tree-army"></div>
                </div>
                <div style="width: 2px; background: #4c566a;"></div>
                <div class="tech-col">
                    <h3 style="color:#a3be8c">Economy</h3>
                    <div id="tech-tree-eco"></div>
                </div>
            </div>
            <button class="secondary" style="margin-top: 20px;" onclick="gameApp.toggleTechTree()">Close</button>
        </div>
    </div>
    
    <!-- Diplomacy Modal -->
    <div id="diplomacy-modal" class="modal hidden">
        <div class="menu-card" style="max-width: 600px;">
            <h2 class="medieval-font">Diplomacy & Trade</h2>
            <div id="diplomacy-list" style="text-align: left; max-height: 300px; overflow-y: auto;"></div>
            
            <div style="margin-top: 20px; border-top: 1px solid #4c566a; padding-top: 10px;">
                <h3 class="medieval-font" style="font-size: 1rem;">Secure Channel</h3>
                <div style="display: flex; gap: 5px;">
                    <input type="text" id="chat-input" placeholder="Send a message..." style="margin: 0;">
                    <button onclick="gameApp.sendChat()">Send</button>
                </div>
            </div>
            
            <div style="margin-top: 20px;">
                <button class="secondary" style="margin-top: 10px;" onclick="gameApp.toggleDiplomacy()">Close</button>
            </div>
        </div>
    </div>
    
    <!-- System Menu Modal -->
    <div id="system-modal" class="modal hidden">
        <div class="menu-card" style="max-width: 400px;">
            <h2 class="medieval-font">System Menu</h2>
            <button class="action-btn" onclick="gameApp.saveGame()">Save Game (Download)</button>
            <button class="action-btn" onclick="gameApp.toggleSystemMenu()">Resume</button>
            <hr style="border-color: #4c566a; margin: 15px 0;">
            <button class="action-btn danger" onclick="gameApp.surrenderGame()">Surrender / End Game</button>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal hidden">
        <div class="menu-card">
            <h1 class="medieval-font" id="winner-title">Victory!</h1>
            <p id="winner-message">The enemy has been vanquished.</p>
            <button onclick="location.reload()">Return to Menu</button>
        </div>
    </div>
</div>

<script>
/**
 * CONSTANTS & CONFIG
 */
const TILE_SIZE = 64; 
const MAP_SIZE = 50; 
const TURN_TIME = 45; 

const FACTION_INFO = {
    PEASANT_REBELLION: "Peasants cost -1 Gold.",
    TECHNOLOGISTS: "Tech costs 30% less.",
    ORDER_OF_KNIGHTS: "Knights -1 Gold, but Knight Tech cost +50%.",
    MARITIME_MERCHANTS: "Boats cost -1 Gold."
};

const FACTION_COLORS = ['#bf616a', '#d08770', '#ebcb8b', '#a3be8c', '#b48ead'];
const FACTION_TYPES = Object.keys(FACTION_INFO);

const TERRAIN = {
    WATER: 0,
    LAND: 1,
    MOUNTAIN: 2
};

const UNITS = {
    PEASANT: { name: "Peasant", cost: 2, atk: 1, def: 1, range: 1, move: 1, sym: "üßë‚Äçüåæ" },
    ARCHER: { name: "Archer", cost: 3, atk: 1, def: 1, range: 2, move: 1, sym: "üèπ" },
    KNIGHT: { name: "Knight", cost: 4, atk: 1, def: 2, range: 1, move: 3, sym: "üêé" }, // Requires Iron
    CATAPULT: { name: "Catapult", cost: 5, atk: 1, def: 5, range: 3, move: 1, sym: "üèóÔ∏è" },
    TRADE_BOAT: { name: "Trade Boat", cost: 5, atk: 0, def: 1, range: 0, move: 1, sym: "‚õµ" },
    WAR_BOAT: { name: "War Boat", cost: 10, atk: 2, def: 1, range: 1, move: 1, sym: "üõ∂" }
};

const STRUCTURES = {
    CAPITAL: { name: "Capital", hp: 30, sym: "üè∞" },
    FORT: { name: "Fort", hp: 10, sym: "üèØ" },
    DOCK: { name: "Dock", hp: 10, sym: "‚öì" },
    MINE_GOLD: { name: "Gold Mine", hp: 5, sym: "üí∞" },
    MINE_IRON: { name: "Iron Mine", hp: 5, sym: "‚õèÔ∏è" }
};

const TECHS = {
    ARCHERY: { name: "Archery", cost: 10, cat: "ARMY", unlocks: "ARCHER" },
    CHIVALRY: { name: "Chivalry", cost: 20, cat: "ARMY", unlocks: "KNIGHT", reqRes: "IRON" },
    SIEGE: { name: "Siegecraft", cost: 30, cat: "ARMY", unlocks: "CATAPULT", reqRes: "IRON" },
    FARMING: { name: "Farming", cost: 20, cat: "ECO", desc: "+Income" },
    FISHING: { name: "Fishing", cost: 20, cat: "ECO", desc: "Unlocks Docks", unlocks: "BOATS" },
    BANKING: { name: "Banking", cost: 40, cat: "ECO", desc: "+Interest" }
};

/**
 * GAME ENGINE SERVICES
 */
class GameEngine {
    static createInitialState(config, lobbySlots) {
        const map = this.generateMap(config.mapType);
        const players = lobbySlots.map((slot, i) => ({
            id: slot.id || `ai_${i}`,
            name: slot.name,
            type: slot.type, 
            difficulty: slot.difficulty || 'MEDIUM',
            faction: slot.faction,
            color: FACTION_COLORS[i % FACTION_COLORS.length],
            isAlive: true,
            gold: 10,
            techs: []
        }));

        const spawnPoints = this.getSpawnPoints(map, players.length);
        players.forEach((p, i) => {
            const sp = spawnPoints[i];
            if(sp) {
                map[sp.y][sp.x].structure = { type: 'CAPITAL', hp: 30, ownerId: p.id };
                map[sp.y][sp.x].ownerId = p.id;
                map[sp.y][sp.x].unit = {
                    id: `u_${Math.random()}`,
                    type: 'PEASANT',
                    ownerId: p.id,
                    hp: 1, maxHp: 1, movesLeft: 1, hasAttacked: false, path: []
                };
            }
        });

        return {
            map,
            players,
            currentPlayerIndex: 0,
            turn: 1,
            phase: 'PLAYING',
            logs: ["Game Started."],
            timeLeft: TURN_TIME
        };
    }

    static generateMap(type) {
        const map = [];
        for (let y = 0; y < MAP_SIZE; y++) {
            const row = [];
            for (let x = 0; x < MAP_SIZE; x++) {
                row.push({ x, y, terrain: TERRAIN.WATER, ownerId: null, unit: null, structure: null });
            }
            map.push(row);
        }

        if (type === 'SIMPLE_SQUARE') {
            const inset = 5;
            for (let y = inset; y < MAP_SIZE - inset; y++) {
                for (let x = inset; x < MAP_SIZE - inset; x++) {
                    map[y][x].terrain = TERRAIN.LAND;
                }
            }
        } else if (type === 'CYPRUS') {
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const nx = x / MAP_SIZE;
                    const ny = y / MAP_SIZE;
                    
                    const dx = (nx - 0.4);
                    const dy = (ny - 0.6);
                    const distMain = (dx * dx) / 0.04 + (dy * dy) / 0.015;
                    
                    const px = nx, py = ny;
                    // Karpas Peninsula
                    const x1=0.5, y1=0.5, x2=0.9, y2=0.25;
                    const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
                    const dot = A * C + B * D;
                    const len_sq = C * C + D * D;
                    let param = -1;
                    if (len_sq !== 0) param = dot / len_sq;
                    let xx, yy;
                    if (param < 0) { xx = x1; yy = y1; }
                    else if (param > 1) { xx = x2; yy = y2; }
                    else { xx = x1 + param * C; yy = y1 + param * D; }
                    const distToKarpas = Math.sqrt((px - xx) * (px - xx) + (py - yy) * (py - yy));
                    
                    let isLand = false;

                    if (distMain <= 1.0) isLand = true;
                    if (distToKarpas < 0.04) isLand = true; 

                    if (Math.sqrt(Math.pow(nx - 0.4, 2) + Math.pow(ny - 0.8, 2)) < 0.05) isLand = true;

                    if (isLand) {
                        map[y][x].terrain = TERRAIN.LAND;
                        
                        // Troodos Mountains (West/Central)
                        if (Math.sqrt(Math.pow(nx - 0.35, 2) + Math.pow(ny - 0.6, 2)) < 0.08) {
                            map[y][x].terrain = TERRAIN.MOUNTAIN;
                        }
                        
                        // Removed Eastern Mountains (Kyrenia/Karpas Range)
                        // if (nx >= 0.25 && nx <= 0.75 && Math.abs(ny - 0.45 - (nx-0.4)*0.1) < 0.02) {
                        //    map[y][x].terrain = TERRAIN.MOUNTAIN;
                        // }
                    }
                }
            }
        } else {
            // RANDOM
            const seeds = [];
            for(let i=0; i<12; i++) {
                seeds.push({
                    x: Math.floor(Math.random() * MAP_SIZE),
                    y: Math.floor(Math.random() * MAP_SIZE),
                    r: Math.random() * (MAP_SIZE/6) + 2
                });
            }
            
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if(x<2 || y<2 || x>MAP_SIZE-3 || y>MAP_SIZE-3) continue;
                    let h = 0;
                    for(let s of seeds) {
                        const d = Math.sqrt((x-s.x)**2 + (y-s.y)**2);
                        if(d < s.r) h += (s.r - d);
                    }
                    if (h > 2) map[y][x].terrain = TERRAIN.LAND;
                    if (h > 6) map[y][x].terrain = TERRAIN.MOUNTAIN;
                }
            }
        }
        return map;
    }

    static getSpawnPoints(map, count) {
        const points = [];
        const seeds = [
            {x:5, y:5}, {x:MAP_SIZE-5, y:MAP_SIZE-5},
            {x:MAP_SIZE-5, y:5}, {x:5, y:MAP_SIZE-5},
            {x:MAP_SIZE/2, y:MAP_SIZE/2}
        ];
        
        for(let i=0; i<count; i++) {
            let seed = seeds[i%seeds.length];
            let spot = this.findNearestLand(map, seed.x, seed.y);
            points.push(spot);
        }
        return points;
    }

    static findNearestLand(map, startX, startY) {
        let x = Math.floor(startX);
        let y = Math.floor(startY);
        if(this.isLand(map, x, y)) return {x,y};
        
        let d = 1;
        while(d < MAP_SIZE) {
            for (let i = 0; i < d + 1; i++) {
                if(this.isLand(map, x-d+i, y-d)) return {x: x-d+i, y: y-d};
                if(this.isLand(map, x+i, y-d)) return {x: x+i, y: y-d};
                if(this.isLand(map, x-d, y-d+i)) return {x: x-d, y: y-d+i};
            }
            for(let k=0; k<20; k++) {
                let rx = Math.floor(x + (Math.random() * d*2) - d);
                let ry = Math.floor(y + (Math.random() * d*2) - d);
                if(this.isLand(map, rx, ry)) return {x:rx, y:ry};
            }
            d += 2;
        }
        return {x: Math.floor(MAP_SIZE/2), y: Math.floor(MAP_SIZE/2)};
    }
    
    static isLand(map, x, y) {
        if(x>=0 && x<MAP_SIZE && y>=0 && y<MAP_SIZE) {
            return map[y][x].terrain === TERRAIN.LAND;
        }
        return false;
    }

    static canMove(unit, fromTile, toTile) {
        if (unit.movesLeft <= 0) return false;
        if (toTile.unit) return false; 
        
        const dx = Math.abs(fromTile.x - toTile.x);
        const dy = Math.abs(fromTile.y - toTile.y);
        const dist = dx + dy; 
        
        if (dist > unit.move) return false; 

        const isBoat = unit.type.includes('BOAT');
        if (isBoat && toTile.terrain !== TERRAIN.WATER) return false;
        if (!isBoat && toTile.terrain === TERRAIN.WATER && !toTile.structure) return false; 
        if (toTile.terrain === TERRAIN.MOUNTAIN) return false; 

        return true;
    }
    
    static findPath(map, unit, start, end) {
        const openSet = [start];
        const cameFrom = {};
        const gScore = {};
        const fScore = {};
        
        const key = (pt) => `${pt.x},${pt.y}`;
        
        gScore[key(start)] = 0;
        fScore[key(start)] = Math.abs(start.x - end.x) + Math.abs(start.y - end.y);
        
        let iterations = 0;
        while(openSet.length > 0 && iterations++ < 500) { 
            let current = openSet[0];
            let lowestF = fScore[key(current)] || Infinity;
            let currentIdx = 0;
            
            for(let i=1; i<openSet.length; i++) {
                const sc = fScore[key(openSet[i])] || Infinity;
                if(sc < lowestF) {
                    lowestF = sc;
                    current = openSet[i];
                    currentIdx = i;
                }
            }
            
            if(current.x === end.x && current.y === end.y) {
                const path = [];
                let curr = current;
                while(cameFrom[key(curr)]) {
                    path.unshift(curr);
                    curr = cameFrom[key(curr)];
                }
                return path;
            }
            
            openSet.splice(currentIdx, 1);
            
            const neighbors = [
                {x: current.x+1, y: current.y}, {x: current.x-1, y: current.y},
                {x: current.x, y: current.y+1}, {x: current.x, y: current.y-1}
            ];
            
            for(let neighbor of neighbors) {
                if(neighbor.x < 0 || neighbor.x >= MAP_SIZE || neighbor.y < 0 || neighbor.y >= MAP_SIZE) continue;
                
                const targetTile = map[neighbor.y][neighbor.x];
                const isBoat = unit.type.includes('BOAT');
                if (targetTile.terrain === TERRAIN.MOUNTAIN) continue;
                if (isBoat && targetTile.terrain !== TERRAIN.WATER) continue;
                if (!isBoat && targetTile.terrain === TERRAIN.WATER && !targetTile.structure) continue;
                
                const tentativeG = (gScore[key(current)] || Infinity) + 1;
                
                if(tentativeG < (gScore[key(neighbor)] || Infinity)) {
                    cameFrom[key(neighbor)] = current;
                    gScore[key(neighbor)] = tentativeG;
                    fScore[key(neighbor)] = tentativeG + Math.abs(neighbor.x - end.x) + Math.abs(neighbor.y - end.y);
                    if(!openSet.find(n => n.x === neighbor.x && n.y === neighbor.y)) {
                        openSet.push(neighbor);
                    }
                }
            }
        }
        return null;
    }
    
    static getIncome(player, map) {
        let income = 0;
        for (let row of map) {
            for (let tile of row) {
                if (tile.ownerId === player.id) income += 0.5;
                if (tile.structure && tile.structure.ownerId === player.id && tile.structure.type === 'MINE_GOLD') income += 5;
            }
        }
        if (player.techs.includes('FARMING')) income += 5;
        if (player.techs.includes('BANKING')) income += Math.floor(player.gold * 0.05);
        return Math.floor(income);
    }

    static nextTurn(state) {
        let nextIdx = (state.currentPlayerIndex + 1) % state.players.length;
        let loopGuard = 0;
        while(!state.players[nextIdx].isAlive && loopGuard < state.players.length) {
            nextIdx = (nextIdx + 1) % state.players.length;
            loopGuard++;
        }
        
        state.currentPlayerIndex = nextIdx;
        if (nextIdx === 0) state.turn++;
        state.timeLeft = TURN_TIME;

        const player = state.players[nextIdx];
        
        // Reset Moves
        for (let row of state.map) {
            for (let tile of row) {
                if (tile.unit && tile.unit.ownerId === player.id) {
                    tile.unit.movesLeft = UNITS[tile.unit.type].move;
                    tile.unit.hasAttacked = false;
                }
            }
        }
        
        // Process Auto-Moves
        if(player.type === 'HUMAN') { 
             let moved = true;
             let loops = 0;
             while(moved && loops < 5) {
                 moved = false;
                 loops++;
                 for(let r=0; r<MAP_SIZE; r++) {
                     for(let c=0; c<MAP_SIZE; c++) {
                         const t = state.map[r][c];
                         if(t.unit && t.unit.ownerId === player.id && t.unit.path && t.unit.path.length > 0 && t.unit.movesLeft > 0) {
                             const nextStep = t.unit.path[0];
                             const target = state.map[nextStep.y][nextStep.x];
                             
                             if(!target.unit) { 
                                 target.unit = t.unit;
                                 t.unit = null;
                                 target.unit.movesLeft--;
                                 target.unit.path.shift(); 
                                 if(target.terrain === TERRAIN.LAND) target.ownerId = player.id;
                                 moved = true; 
                             } else {
                                 t.unit.path = [];
                                 state.logs.unshift(`${player.name}'s unit blocked en route.`);
                             }
                         }
                     }
                 }
             }
        }

        const income = this.getIncome(player, state.map);
        player.gold += income;
        state.logs.unshift(`Turn ${state.turn}: ${player.name}'s turn. Income: ${income}`);
        
        gameApp.saveLocal();
        
        return state;
    }
}

/**
 * AI LOGIC
 */
class AIPlayer {
    static processTurn(app, gameState) {
        const player = gameState.players[gameState.currentPlayerIndex];
        if (player.type !== 'CPU') return;

        const myUnits = [];
        for(let r=0; r<MAP_SIZE; r++) {
            for(let c=0; c<MAP_SIZE; c++) {
                if(gameState.map[r][c].unit && gameState.map[r][c].unit.ownerId === player.id) {
                    myUnits.push({x: c, y: r, u: gameState.map[r][c].unit});
                }
            }
        }

        myUnits.forEach(unitData => {
            if(unitData.u.movesLeft > 0) {
                this.tryMoveAI(app, unitData, gameState);
            }
        });

        if (player.gold >= 2) app.buyUnit('PEASANT');
        setTimeout(() => app.endTurn(), 1500);
    }

    static tryMoveAI(app, unitData, state) {
        const dx = [0, 0, 1, -1];
        const dy = [1, -1, 0, 0];
        
        for(let i=0; i<4; i++) {
            const nx = unitData.x + dx[i];
            const ny = unitData.y + dy[i];
            if(nx>=0 && nx<MAP_SIZE && ny>=0 && ny<MAP_SIZE) {
                const target = state.map[ny][nx];
                if(GameEngine.canMove(unitData.u, state.map[unitData.y][unitData.x], target)) {
                    if(target.unit && target.unit.ownerId !== unitData.u.ownerId) {
                        app.sendAction({ type: 'ATTACK', from: {x: unitData.x, y: unitData.y}, to: {x: nx, y: ny} });
                        return;
                    }
                    if(!target.unit && target.terrain === TERRAIN.LAND) {
                        app.sendAction({ type: 'MOVE', from: {x: unitData.x, y: unitData.y}, to: {x: nx, y: ny} });
                        return;
                    }
                }
            }
        }
    }
}

/**
 * APP LOGIC
 */
const gameApp = {
    peer: null,
    conn: null,
    peerId: null,
    gameState: null,
    lobbySlots: [], 
    isHost: false,
    view: 'MENU', 
    selection: null,
    dpr: 1,
    
    // Camera & Interaction
    camera: { x: 0, y: 0, zoom: 1 },
    isMouseDown: false,
    isDragging: false,
    lastMouse: { x: 0, y: 0 },
    startMouse: { x: 0, y: 0 },
    hoverTile: null,
    interactionMode: 'NONE', // NONE, MOVE, ATTACK
    
    visibleTiles: new Set(),

    init: function() {
        this.peer = new Peer(null, { debug: 2 });
        this.peer.on('open', (id) => {
            this.peerId = id;
            document.getElementById('my-peer-id').innerText = id;
            document.getElementById('loading-overlay').classList.add('hidden');
        
            if(localStorage.getItem('cw_save')) {
                document.getElementById('resume-btn').classList.remove('hidden');
            }
        });
        this.peer.on('connection', (c) => {
            this.setupConnection(c);
        });

        const canvas = document.getElementById('game-canvas');
        
        // Mouse / Touch Events for Interaction
        canvas.addEventListener('mousedown', (e) => {
            this.isMouseDown = true;
            this.isDragging = false;
            this.lastMouse = { x: e.clientX, y: e.clientY };
            this.startMouse = { x: e.clientX, y: e.clientY };
        });
        window.addEventListener('mouseup', (e) => {
            this.isMouseDown = false;
            if(!this.isDragging) {
                this.doTileClickLogic(e);
            }
            this.isDragging = false;
        });
        window.addEventListener('mousemove', (e) => {
            // Hover Logic
            this.updateHover(e);
            
            if(this.isMouseDown && this.lastMouse) {
                 const dx = e.clientX - this.lastMouse.x;
                 const dy = e.clientY - this.lastMouse.y;
                 // Drag threshold
                 if (Math.abs(e.clientX - this.startMouse.x) > 5 || Math.abs(e.clientY - this.startMouse.y) > 5) {
                     this.isDragging = true;
                 }
                 
                 if(this.isDragging) {
                    this.camera.x += dx;
                    this.camera.y += dy;
                    this.renderGame();
                 }
                 this.lastMouse = { x: e.clientX, y: e.clientY };
            }
        });
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            if(e.deltaY < 0) this.camera.zoom = Math.min(2, this.camera.zoom + zoomSpeed);
            else this.camera.zoom = Math.max(0.5, this.camera.zoom - zoomSpeed);
            this.renderGame();
        }, { passive: false });

        window.addEventListener('resize', () => this.resizeCanvas());
        setInterval(() => this.gameLoop(), 1000);
    },
    
    updateHover: function(e) {
        if(!this.gameState || this.isDragging) return;
        const rect = document.getElementById('game-canvas').getBoundingClientRect();
        const screenX = (e.clientX - rect.left);
        const screenY = (e.clientY - rect.top);
        
        const zoom = this.camera.zoom;
        const camX = this.camera.x + window.innerWidth/2;
        const camY = this.camera.y + 100;
        
        const adjX = (screenX - camX) / zoom;
        const adjY = (screenY - camY) / zoom;

        const col = Math.floor((adjY * 2 + adjX) / TILE_SIZE);
        const row = Math.floor((adjY * 2 - adjX) / TILE_SIZE);
        
        if(col >= 0 && col < MAP_SIZE && row >= 0 && row < MAP_SIZE) {
            if (!this.hoverTile || this.hoverTile.x !== col || this.hoverTile.y !== row) {
                this.hoverTile = {x: col, y: row};
                this.renderGame();
            }
        } else {
            this.hoverTile = null;
        }
    },

    setupConnection: function(c) {
        c.on('data', (data) => this.handleNetworkMessage(data, c));
        c.on('open', () => {
            if (this.isHost) {
                c.send({ type: 'LOBBY_UPDATE', slots: this.lobbySlots });
            }
        });
        if (this.isHost && !this.connections) this.connections = [];
        if (this.isHost) this.connections.push(c);
        else this.conn = c; 
    },

    handleNetworkMessage: function(msg, sender) {
        switch(msg.type) {
            case 'JOIN_REQUEST':
                if(this.isHost) {
                    const emptySlotIdx = this.lobbySlots.findIndex(s => s.type === 'HUMAN' && !s.id);
                    if (emptySlotIdx !== -1) {
                        this.lobbySlots[emptySlotIdx] = {
                            ...this.lobbySlots[emptySlotIdx],
                        id: sender.peer,
                        name: msg.player.name,
                            ready: true
                    };
                        this.broadcast({ type: 'LOBBY_UPDATE', slots: this.lobbySlots });
                    }
                }
                break;
            case 'LOBBY_UPDATE':
                this.lobbySlots = msg.slots;
                this.renderLobby();
                break;
            case 'SYNC_STATE':
                const isFirstSync = !this.gameState;
                this.gameState = msg.state;
                // this.calculateVisibility(); // DISABLED
                if (this.view !== 'GAME') this.switchView('GAME');
                if (isFirstSync) this.centerCamera();
                this.checkTurnNotification();
                this.renderGame();
                this.updateHUD();
                break;
            case 'DIPLOMACY':
                // Handle chat or trade
                if(this.gameState) {
                    this.gameState.logs.unshift(`[DIP] ${msg.content}`);
                    if(this.isHost && msg.action === 'GIVE_GOLD') {
                        // Process transaction
                        const fromP = this.gameState.players.find(p => p.id === msg.fromId);
                        const toP = this.gameState.players.find(p => p.id === msg.toId);
                        if(fromP && toP && fromP.gold >= msg.amount) {
                            fromP.gold -= msg.amount;
                            toP.gold += parseInt(msg.amount);
                            this.gameState.logs.unshift(`${fromP.name} sent ${msg.amount}g to ${toP.name}`);
                            this.broadcast({ type: 'SYNC_STATE', state: this.gameState });
                        }
                    }
                    if(msg.action === 'SURRENDER') {
                        const p = this.gameState.players.find(p => p.id === msg.fromId);
                        if(p) {
                            p.isAlive = false;
                            this.gameState.logs.unshift(`${p.name} has surrendered!`);
                            this.broadcast({ type: 'SYNC_STATE', state: this.gameState });
                        }
                    }
                    this.updateHUD();
                }
                break;
        }
    },
    
    checkTurnNotification: function() {
        if(!this.gameState) return;
        const turnPlayer = this.gameState.players[this.gameState.currentPlayerIndex];
        const el = document.getElementById('turn-notification');
        if (turnPlayer.id === this.peerId) {
            el.innerText = "YOUR TURN";
            el.style.color = "#ebcb8b";
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 2000);
        } else {
            // Optional: Show who is playing briefly? No, too noisy.
        }
    },

    broadcast: function(msg) {
        if (this.isHost && this.connections) {
            this.connections.forEach(c => c.send(msg));
            if(msg.type === 'SYNC_STATE') {
                this.gameState = msg.state;
                // this.calculateVisibility(); // DISABLED
            }
        } else if (this.conn) {
            this.conn.send(msg); 
        }
    },

    hostGame: function() {
        this.isHost = true;
        this.lobbySlots = [{
            id: this.peerId,
            name: document.getElementById('player-name').value,
            type: 'HUMAN',
            faction: 'PEASANT_REBELLION',
            ready: true
        }];
        this.addSlot();
        this.switchView('LOBBY');
        this.renderLobby();
    },

    joinGame: function() {
        const hostId = document.getElementById('host-id-input').value;
        if(!hostId) return alert("Enter Host ID");
        this.isHost = false;
        const conn = this.peer.connect(hostId);
        this.setupConnection(conn);
        conn.on('open', () => {
            conn.send({
                type: 'JOIN_REQUEST',
                player: { name: document.getElementById('player-name').value }
            });
            this.switchView('LOBBY');
        });
    },

    addSlot: function() {
        if(this.lobbySlots.length >= 5) return;
        this.lobbySlots.push({
            id: null,
            name: `AI Player ${this.lobbySlots.length}`,
            type: 'CPU',
            difficulty: 'MEDIUM',
            faction: FACTION_TYPES[this.lobbySlots.length % FACTION_TYPES.length],
            ready: true
        });
        this.broadcast({ type: 'LOBBY_UPDATE', slots: this.lobbySlots });
        this.renderLobby();
    },
    
    updateSlot: function(idx, field, value) {
        if(!this.isHost) return;
        this.lobbySlots[idx][field] = value;
        this.broadcast({ type: 'LOBBY_UPDATE', slots: this.lobbySlots });
        this.renderLobby();
    },
    
    removeSlot: function(idx) {
        if(!this.isHost) return;
        this.lobbySlots.splice(idx, 1);
        this.broadcast({ type: 'LOBBY_UPDATE', slots: this.lobbySlots });
        this.renderLobby();
    },

    startGame: function() {
        if(!this.isHost) return;
        const config = { mapType: document.getElementById('map-type').value };
        const initialState = GameEngine.createInitialState(config, this.lobbySlots);
        this.gameState = initialState;
        // this.calculateVisibility(); // DISABLED
        this.broadcast({ type: 'SYNC_STATE', state: initialState });
        this.switchView('GAME');
        this.resizeCanvas();
        this.centerCamera();
        this.checkTurnNotification();
        this.renderGame();
    },

    gameLoop: function() {
        if (!this.gameState || !this.isHost) return;
        
        if (this.gameState.timeLeft > 0) {
            this.gameState.timeLeft--;
        } else {
            this.endTurn(); 
            return;
        }
        
        const currP = this.gameState.players[this.gameState.currentPlayerIndex];
        if (currP.type === 'CPU') {
            if (Math.random() > 0.8) AIPlayer.processTurn(this, this.gameState);
        }
        this.updateHUD();
    },

    switchView: function(viewName) {
        this.view = viewName;
        document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
        if(viewName === 'MENU') document.getElementById('menu-view').classList.add('active');
        if(viewName === 'LOBBY') document.getElementById('lobby-view').classList.add('active');
        if(viewName === 'GAME') document.getElementById('game-view').classList.add('active');

        if(viewName === 'LOBBY') {
            if(this.isHost) {
                document.getElementById('host-controls').classList.remove('hidden');
                document.getElementById('client-controls').classList.add('hidden');
            } else {
                document.getElementById('host-controls').classList.add('hidden');
                document.getElementById('client-controls').classList.remove('hidden');
            }
        }
    },

    renderLobby: function() {
        const list = document.getElementById('lobby-slots');
        list.innerHTML = '';
        this.lobbySlots.forEach((slot, idx) => {
            const div = document.createElement('div');
            div.className = 'player-item';
            const color = FACTION_COLORS[idx % FACTION_COLORS.length];
            
            const typeSelect = this.isHost ? `
                <select onchange="gameApp.updateSlot(${idx}, 'type', this.value)">
                    <option value="HUMAN" ${slot.type==='HUMAN'?'selected':''}>Human</option>
                    <option value="CPU" ${slot.type==='CPU'?'selected':''}>CPU</option>
                </select>
            ` : slot.type;
            
            const factionSelect = this.isHost ? `
                <select onchange="gameApp.updateSlot(${idx}, 'faction', this.value)">
                    ${FACTION_TYPES.map(f => `<option value="${f}" ${slot.faction===f?'selected':''}>${f}</option>`).join('')}
                </select>
            ` : slot.faction;

            const nameDisplay = (slot.type === 'CPU' && this.isHost) 
                ? `<input type="text" value="${slot.name}" onchange="gameApp.updateSlot(${idx}, 'name', this.value)" style="margin:0;padding:5px;">` 
                : `<span>${slot.name} ${slot.id ? '(Connected)' : '(Waiting...)'}</span>`;
            const removeBtn = (this.isHost && idx !== 0) 
                ? `<button class="danger" onclick="gameApp.removeSlot(${idx})" style="padding:5px; font-size:0.8rem;">X</button>` 
                : ``;

            div.innerHTML = `<div style="width:20px;height:20px;border-radius:50%;background:${color}"></div>${nameDisplay}${typeSelect}${factionSelect}${removeBtn}`;
            list.appendChild(div);
        });
    },
    
    handleCanvasClick: function(e) {
    },
    
    doTileClickLogic: function(e) {
        if (!this.gameState) return;
        const rect = e.target.getBoundingClientRect();
        const screenX = (e.clientX - rect.left);
        const screenY = (e.clientY - rect.top);
        
        // Adjust for Camera
        const zoom = this.camera.zoom;
        const camX = this.camera.x + window.innerWidth/2;
        const camY = this.camera.y + 100;
        
        const adjX = (screenX - camX) / zoom;
        const adjY = (screenY - camY) / zoom;

        // Inverse Iso (Approximate hit testing)
        const col = Math.floor((adjY * 2 + adjX) / TILE_SIZE);
        const row = Math.floor((adjY * 2 - adjX) / TILE_SIZE);
        
        if(col >= 0 && col < MAP_SIZE && row >= 0 && row < MAP_SIZE) {
            this.onTileInteraction(col, row);
        }
    },

    onTileInteraction: function(x, y) {
        const state = this.gameState;
        const currentPlayer = state.players[state.currentPlayerIndex];
        if (currentPlayer.id !== this.peerId) return;

        const targetTile = state.map[y][x];
        const clickedUnit = targetTile.unit;

        if (this.selection) {
            const prevTile = state.map[this.selection.y][this.selection.x];
            const selectedUnit = prevTile.unit;
            
            // STRICT MODE LOGIC
            if (selectedUnit && selectedUnit.ownerId === this.peerId) {
                if (this.interactionMode === 'MOVE') {
                    if (GameEngine.canMove(selectedUnit, prevTile, targetTile)) {
                        this.sendAction({ type: 'MOVE', from: {x: this.selection.x, y: this.selection.y}, to: {x, y} });
                        this.selection = null;
                        this.interactionMode = 'NONE';
                    } else if (!targetTile.unit && !targetTile.structure && !GameEngine.canMove(selectedUnit, prevTile, targetTile)) {
                         // Auto-path
                         const path = GameEngine.findPath(state.map, selectedUnit, {x: this.selection.x, y: this.selection.y}, {x, y});
                         if (path && path.length > 0) {
                             this.sendAction({ type: 'SET_PATH', from: {x: this.selection.x, y: this.selection.y}, path: path });
                             this.selection = null;
                             this.interactionMode = 'NONE';
                         }
                    }
                } else if (this.interactionMode === 'ATTACK') {
                    if (clickedUnit && clickedUnit.ownerId !== this.peerId) {
                         const dist = Math.abs(x - this.selection.x) + Math.abs(y - this.selection.y);
                         if (dist <= UNITS[selectedUnit.type].range && !selectedUnit.hasAttacked) {
                             this.sendAction({ type: 'ATTACK', from: {x: this.selection.x, y: this.selection.y}, to: {x, y} });
                             this.selection = null;
                             this.interactionMode = 'NONE';
                         }
                    }
                }
                
                // If clicking self or changing selection
                if (clickedUnit && clickedUnit.ownerId === this.peerId) {
                    this.selection = {x, y};
                    this.interactionMode = 'NONE'; // Reset on new selection
                } else if (targetTile.structure && targetTile.ownerId === this.peerId) {
                    this.selection = {x, y};
                    this.interactionMode = 'NONE';
                }
                
            } else {
                // Structure selected or Enemy selected (observation)
                if((clickedUnit && clickedUnit.ownerId === this.peerId) || (targetTile.structure && targetTile.ownerId === this.peerId)) {
                    this.selection = {x, y};
                    this.interactionMode = 'NONE';
                } else {
                    this.selection = null;
                    this.interactionMode = 'NONE';
                }
            }
        } else {
            if ((clickedUnit && clickedUnit.ownerId === this.peerId) || (targetTile.structure && targetTile.ownerId === this.peerId)) {
                this.selection = {x, y};
                this.interactionMode = 'NONE';
            }
        }
        this.renderGame();
        this.updateHUD();
    },

    // Fog Helper - Optimized (DISABLED)
    calculateVisibility: function() {
        return; // Fog of War disabled
    },

    sendAction: function(action) {
        const newState = JSON.parse(JSON.stringify(this.gameState));
        const player = newState.players[newState.currentPlayerIndex];
        
        if (action.type === 'MOVE') {
            const u = newState.map[action.from.y][action.from.x].unit;
            newState.map[action.to.y][action.to.x].unit = u;
            newState.map[action.from.y][action.from.x].unit = null;
            
            const dist = Math.abs(action.from.x - action.to.x) + Math.abs(action.from.y - action.to.y);
            u.movesLeft -= dist; 
            if (u.movesLeft < 0) u.movesLeft = 0; 
            u.path = []; 

            if (newState.map[action.to.y][action.to.x].terrain === TERRAIN.LAND) {
                newState.map[action.to.y][action.to.x].ownerId = player.id;
            }
            newState.logs.unshift(`${player.name} moved ${UNITS[u.type].name}`);
        }
        if (action.type === 'SET_PATH') {
            const u = newState.map[action.from.y][action.from.x].unit;
            u.path = action.path;
            if(u.movesLeft > 0 && u.path.length > 0) {
                const nextStep = u.path[0];
                newState.map[nextStep.y][nextStep.x].unit = u;
                newState.map[action.from.y][action.from.x].unit = null;
                u.movesLeft--;
                u.path.shift();
                if(newState.map[nextStep.y][nextStep.x].terrain === TERRAIN.LAND) newState.map[nextStep.y][nextStep.x].ownerId = player.id;
                newState.logs.unshift(`${player.name} auto-moved ${UNITS[u.type].name}`);
            }
        }
        if (action.type === 'ATTACK') {
            const attacker = newState.map[action.from.y][action.from.x].unit;
            const defender = newState.map[action.to.y][action.to.x].unit;
            
            const dmg = Math.max(0, UNITS[attacker.type].atk - (UNITS[defender.type].def * 0.1)); 
            let finalDmg = 1; 
            if(attacker.type === 'KNIGHT' && defender.type === 'ARCHER') finalDmg = 2;
            if(attacker.type === 'ARCHER' && defender.type === 'PEASANT') finalDmg = 1;
            
            defender.hp -= finalDmg;
            attacker.hasAttacked = true;
            attacker.movesLeft = 0;
            attacker.path = []; 
            
            newState.logs.unshift(`${player.name}'s ${UNITS[attacker.type].name} hit ${UNITS[defender.type].name} for ${finalDmg} dmg!`);
            
            if (defender.hp <= 0) {
                 newState.map[action.to.y][action.to.x].unit = null;
                 newState.logs.unshift(`Enemy unit destroyed!`);
            } else {
                const dist = Math.abs(action.from.x - action.to.x) + Math.abs(action.from.y - action.to.y);
                const defRange = UNITS[defender.type].range;
                
                if (dist <= defRange) {
                    const retDmg = Math.max(1, Math.floor(UNITS[defender.type].atk * 0.5));
                    attacker.hp -= retDmg;
                    newState.logs.unshift(`Defender retaliated for ${retDmg} dmg!`);
                    if(attacker.hp <= 0) {
                        newState.map[action.from.y][action.from.x].unit = null;
                        newState.logs.unshift(`Attacker died in counter-attack!`);
                    }
                }
            }
        }
        if (action.type === 'END_TURN') {
            GameEngine.nextTurn(newState);
            this.checkTurnNotification();
        }
        if (action.type === 'BUY_UNIT') {
             let spawned = false;
             const cost = UNITS[action.unitType].cost;
             let actualCost = cost;
             if (player.faction === 'PEASANT_REBELLION' && action.unitType === 'PEASANT') actualCost -= 1;
             if (player.faction === 'MARITIME_MERCHANTS' && action.unitType.includes('BOAT')) actualCost -= 1;
             if (player.faction === 'ORDER_OF_KNIGHTS' && action.unitType === 'KNIGHT') actualCost -= 1;
             
             if (player.gold >= actualCost) {
                 for(let r=0; r<MAP_SIZE; r++) {
                     for(let c=0; c<MAP_SIZE; c++) {
                         const t = newState.map[r][c];
                         if(t.ownerId === player.id && !t.unit && t.structure) {
                             const isWater = action.unitType.includes('BOAT');
                             const isDock = t.structure.type === 'DOCK';
                             if(isWater === isDock || (!isWater && !isDock)) {
                                 t.unit = {
                                     id: `u_${Math.random()}`,
                                     type: action.unitType,
                                     ownerId: player.id,
                                     hp: 5, maxHp: 5, movesLeft: 0, hasAttacked: true, path: []
                                 };
                                 player.gold -= actualCost;
                                 spawned = true;
                                 break;
                             }
                         }
                     }
                     if(spawned) break;
                 }
                 if(spawned) newState.logs.unshift(`${player.name} recruited ${action.unitType}`);
             } 
        }
        if (action.type === 'RESEARCH') {
            if (player.gold >= action.cost && !player.techs.includes(action.techId)) {
                player.gold -= action.cost;
                player.techs.push(action.techId);
                newState.logs.unshift(`${player.name} researched ${TECHS[action.techId].name}`);
            }
        }
        if (action.type === 'BUILD_FORT') {
            const t = newState.map[action.at.y][action.at.x];
            if(t.unit && t.ownerId === player.id && player.gold >= 15) {
                 player.gold -= 15;
                 t.unit = null; // Consume unit
                 t.structure = { type: 'FORT', hp: 10, ownerId: player.id };
                 newState.logs.unshift(`${player.name} built a Fort.`);
            }
        }

        this.gameState = newState;
        // this.calculateVisibility(); // DISABLED
        this.broadcast({ type: 'SYNC_STATE', state: newState });
        this.renderGame();
        this.updateHUD();
    },

    endTurn: function() {
        this.sendAction({ type: 'END_TURN' });
    },
    
    buyUnit: function(type) {
        this.sendAction({ type: 'BUY_UNIT', unitType: type });
    },
    
    researchTech: function(techId, cost) {
        this.sendAction({ type: 'RESEARCH', techId, cost });
    },
    
    buildFort: function(x, y) {
        this.sendAction({ type: 'BUILD_FORT', at: {x, y} });
    },
    
    giveGold: function(targetId) {
        const amount = prompt("Amount of Gold to send:");
        if(amount && !isNaN(amount)) {
            if(this.isHost) {
                const msg = { type: 'DIPLOMACY', action: 'GIVE_GOLD', fromId: this.peerId, toId: targetId, amount: parseInt(amount), content: `sent ${amount}g` };
                this.handleNetworkMessage(msg);
            } else {
                this.conn.send({ type: 'DIPLOMACY', action: 'GIVE_GOLD', fromId: this.peerId, toId: targetId, amount: parseInt(amount), content: `sent ${amount}g` });
            }
        }
    },
    
    sendChat: function() {
        const input = document.getElementById('chat-input');
        const msg = input.value;
        if(!msg) return;
        
        const packet = { type: 'DIPLOMACY', action: 'CHAT', content: `${this.lobbySlots.find(p=>p.id===this.peerId)?.name}: ${msg}` };
        
        if(this.isHost) {
            this.handleNetworkMessage(packet);
            this.broadcast(packet);
        } else {
            this.conn.send(packet);
        }
        input.value = '';
    },
    
    // SAVE & LOAD SYSTEM
    saveLocal: function() {
        if(!this.gameState) return;
        localStorage.setItem('cw_save', JSON.stringify({
            state: this.gameState,
            slots: this.lobbySlots,
            myId: this.peerId
        }));
    },
    
    loadFromLocal: function() {
        const data = localStorage.getItem('cw_save');
        if(data) {
            this.isHost = true; // Loading implies hosting
            const parsed = JSON.parse(data);
            this.gameState = parsed.state;
            this.lobbySlots = parsed.slots;
            // Update my ID in slots to current Peer ID
            const oldId = parsed.myId;
            this.lobbySlots.forEach(s => {
                if(s.id === oldId) s.id = this.peerId;
            });
            this.gameState.players.forEach(p => {
                if(p.id === oldId) p.id = this.peerId;
            });
            
            // this.calculateVisibility(); // DISABLED
            this.broadcast({ type: 'SYNC_STATE', state: this.gameState });
            this.switchView('GAME');
            this.resizeCanvas();
            this.centerCamera();
            this.checkTurnNotification();
            this.renderGame();
            this.updateHUD();
        }
    },
    
    saveGame: function() {
        if(!this.gameState) return;
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify({
            state: this.gameState,
            slots: this.lobbySlots
        }));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "cyprus_wars_save.json");
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    },
    
    loadGame: function(input) {
        const file = input.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const parsed = JSON.parse(e.target.result);
            this.isHost = true;
            this.gameState = parsed.state;
            this.lobbySlots = parsed.slots;
            const mySlot = this.lobbySlots.find(s => s.type === 'HUMAN');
            if(mySlot) {
                const oldId = mySlot.id;
                mySlot.id = this.peerId;
                this.gameState.players.forEach(p => {
                    if(p.id === oldId) p.id = this.peerId;
                });
            }
            
            // this.calculateVisibility(); // DISABLED
            this.broadcast({ type: 'SYNC_STATE', state: this.gameState });
            this.switchView('GAME');
            this.resizeCanvas();
            this.centerCamera();
            this.checkTurnNotification();
            this.renderGame();
            this.updateHUD();
        };
        reader.readAsText(file);
    },
    
    toggleSystemMenu: function() {
        document.getElementById('system-modal').classList.toggle('hidden');
    },
    
    surrenderGame: function() {
        if(!this.gameState) return;
        if(confirm("Are you sure you want to surrender?")) {
            if(this.isHost) {
                const packet = { type: 'DIPLOMACY', action: 'SURRENDER', fromId: this.peerId, content: 'Host has ended the game.' };
                this.handleNetworkMessage(packet);
                this.broadcast(packet);
                alert("Game Ended.");
                location.reload();
            } else {
                const packet = { type: 'DIPLOMACY', action: 'SURRENDER', fromId: this.peerId, content: 'I surrender!' };
                this.conn.send(packet);
                alert("You have surrendered.");
                location.reload();
            }
        }
    },

    updateHUD: function() {
        if (!this.gameState) return;
        const myPlayer = this.gameState.players.find(p => p.id === this.peerId) || this.gameState.players[0];
        const turnPlayer = this.gameState.players[this.gameState.currentPlayerIndex];
        
        const income = GameEngine.getIncome(myPlayer, this.gameState.map);
        
        const indicator = document.getElementById('turn-indicator');
        if (turnPlayer.id === this.peerId) {
            indicator.innerText = `YOUR TURN (Turn ${this.gameState.turn})`;
            indicator.style.color = "#a3be8c";
        } else {
            indicator.innerText = `Waiting for ${turnPlayer.name}...`;
            indicator.style.color = "#eceff4";
        }
        
        document.getElementById('timer').innerText = `${this.gameState.timeLeft}s`;
        document.getElementById('gold-display').innerText = myPlayer.gold;
        document.getElementById('income-display').innerText = `+${income}`;
        
        const logDiv = document.getElementById('game-log');
        logDiv.innerHTML = this.gameState.logs.slice(0, 10).map(l => `<div class="log-entry">${l}</div>`).join('');
        
        const selPanel = document.getElementById('selection-panel');
        const selTitle = document.getElementById('selection-title');
        const selDetails = document.getElementById('selection-details');
        const actionBtns = document.getElementById('action-buttons');
        const turnControls = document.getElementById('turn-controls');
        
        actionBtns.innerHTML = '';
        const isMyTurn = (turnPlayer.id === this.peerId);
        
        if (isMyTurn) {
            turnControls.classList.remove('hidden');
        } else {
            turnControls.classList.add('hidden');
        }

        if (this.selection) {
            const tile = this.gameState.map[this.selection.y][this.selection.x];
            if (tile.unit) {
                const uInfo = UNITS[tile.unit.type];
                selTitle.innerText = uInfo.name;
                selDetails.innerHTML = `HP: ${tile.unit.hp} | Move: ${tile.unit.movesLeft}`;
                
                if(isMyTurn && tile.ownerId === this.peerId) {
                    // MOVE & ATTACK OPTIONS
                    const btnContainer = document.createElement('div');
                    btnContainer.style.display = 'flex';
                    btnContainer.style.gap = '5px';
                    btnContainer.style.marginBottom = '5px';
                    
                    const btnMove = document.createElement('button');
                    btnMove.className = 'action-btn';
                    btnMove.style.background = this.interactionMode === 'MOVE' ? '#88c0d0' : '#4c566a';
                    btnMove.innerText = "Move";
                    btnMove.onclick = () => { this.interactionMode = 'MOVE'; this.renderGame(); this.updateHUD(); };
                    
                    const btnAttack = document.createElement('button');
                    btnAttack.className = 'action-btn';
                    btnAttack.style.background = this.interactionMode === 'ATTACK' ? '#bf616a' : '#4c566a';
                    btnAttack.innerText = "Attack";
                    btnAttack.onclick = () => { this.interactionMode = 'ATTACK'; this.renderGame(); this.updateHUD(); };
                    
                    btnContainer.appendChild(btnMove);
                    btnContainer.appendChild(btnAttack);
                    actionBtns.appendChild(btnContainer);

                    if(!tile.structure && tile.terrain === TERRAIN.LAND && tile.unit.movesLeft > 0) {
                        const btn = document.createElement('button');
                        btn.className = 'action-btn';
                        btn.innerText = "Build Fort (15g)";
                        btn.onclick = () => this.buildFort(this.selection.x, this.selection.y);
                        actionBtns.appendChild(btn);
                    }
                }
                
            } else if (tile.structure) {
                const sInfo = STRUCTURES[tile.structure.type];
                selTitle.innerText = sInfo.name;
                selDetails.innerHTML = "Structure";
                if(tile.ownerId === this.peerId && isMyTurn) {
                    if (tile.structure.type === 'CAPITAL' || tile.structure.type === 'FORT') {
                         ['PEASANT', 'ARCHER', 'KNIGHT', 'CATAPULT', 'TRADE_BOAT', 'WAR_BOAT'].forEach(ut => {
                             // CHECK TECH LOCK
                             let unlocked = true;
                             if (ut === 'ARCHER' && !myPlayer.techs.includes('ARCHERY')) unlocked = false;
                             if (ut === 'KNIGHT' && !myPlayer.techs.includes('CHIVALRY')) unlocked = false;
                             if (ut === 'CATAPULT' && !myPlayer.techs.includes('SIEGE')) unlocked = false;
                             if ((ut === 'TRADE_BOAT' || ut === 'WAR_BOAT') && !myPlayer.techs.includes('FISHING')) unlocked = false;
                             
                             if (unlocked) {
                                 const btn = document.createElement('button');
                                 btn.className = 'action-btn';
                                 btn.innerText = `Recruit ${UNITS[ut].name} (${UNITS[ut].cost}g)`;
                                 btn.onclick = () => this.buyUnit(ut);
                                 actionBtns.appendChild(btn);
                             }
                         });
                    }
                }
            } else {
                selTitle.innerText = "Empty Tile";
                selDetails.innerHTML = "";
            }
        } else {
            selTitle.innerText = "No Selection";
            selDetails.innerHTML = "Select a unit or structure.";
        }
    },
    
    toggleTechTree: function() {
        document.getElementById('tech-modal').classList.toggle('hidden');
        this.renderTechTree();
    },
    
    toggleDiplomacy: function() {
        document.getElementById('diplomacy-modal').classList.toggle('hidden');
        this.renderDiplomacy();
    },
    
    renderDiplomacy: function() {
        const list = document.getElementById('diplomacy-list');
        list.innerHTML = '';
        
        this.gameState.players.forEach(p => {
            if(p.id === this.peerId) return; // Don't show self
            
            const div = document.createElement('div');
            div.className = 'diplomacy-item';
            div.innerHTML = `
                <span><span style="color:${p.color}">‚ñ†</span> ${p.name} (${p.faction})</span>
                <button style="padding: 5px 10px; font-size: 0.8rem;" onclick="gameApp.giveGold('${p.id}')">Give Gold</button>
            `;
            list.appendChild(div);
        });
    },
    
    renderTechTree: function() {
        if(!this.gameState) return;
        const myPlayer = this.gameState.players.find(p => p.id === this.peerId) || this.gameState.players[0];
        
        const cArmy = document.getElementById('tech-tree-army');
        const cEco = document.getElementById('tech-tree-eco');
        cArmy.innerHTML = '';
        cEco.innerHTML = '';
        
        Object.keys(TECHS).forEach(k => {
            const t = TECHS[k];
            const hasTech = myPlayer.techs.includes(k);
            const div = document.createElement('div');
            div.className = `tech-tree-node ${hasTech ? 'unlocked' : ''}`;
            
            let content = `<strong>${t.name}</strong><br>`;
            if (hasTech) {
                content += `ACTIVE`;
            } else {
                content += `${t.cost}g`;
            }
            
            div.innerHTML = content;
            
            if (!hasTech) {
                div.onclick = () => this.researchTech(k, t.cost);
            }
            
            if(t.cat === 'ARMY') cArmy.appendChild(div);
            else cEco.appendChild(div);
        });
    },

    resizeCanvas: function() {
        const cvs = document.getElementById('game-canvas');
        this.dpr = window.devicePixelRatio || 1;
        cvs.width = window.innerWidth * this.dpr;
        cvs.height = window.innerHeight * this.dpr;
        cvs.style.width = window.innerWidth + 'px';
        cvs.style.height = window.innerHeight + 'px';
        
        const ctx = cvs.getContext('2d');
        ctx.scale(this.dpr, this.dpr);
        
        this.renderGame();
    },
    
    centerCamera: function() {
        if(!this.gameState) return;
        // Find my unit/structure
        let target = {x: MAP_SIZE/2, y: MAP_SIZE/2};
        
        for(let r=0; r<MAP_SIZE; r++) {
            for(let c=0; c<MAP_SIZE; c++) {
                const t = this.gameState.map[r][c];
                if(t.ownerId === this.peerId || (t.unit && t.unit.ownerId === this.peerId)) {
                    target = {x: c, y: r};
                    break;
                }
            }
        }
        
        // Convert to ISO
        const isoX = (target.x - target.y) * (TILE_SIZE / 2);
        const isoY = (target.x + target.y) * (TILE_SIZE / 4);
        
        // Set Camera to center this
        this.camera.x = -isoX;
        this.camera.y = -isoY;
    },

    renderGame: function() {
        if(!this.gameState) return;
        const cvs = document.getElementById('game-canvas');
        const ctx = cvs.getContext('2d');
        
        // Clear rect logic
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

        const map = this.gameState.map;
        
        // Camera Transforms
        const zoom = this.camera.zoom;
        const camX = this.camera.x;
        const camY = this.camera.y;
        
        const centerX = window.innerWidth / 2;
        const centerY = 100; // vertical padding

        ctx.save();
        // Apply Camera
        ctx.translate(centerX, centerY);
        ctx.scale(zoom, zoom);
        ctx.translate(camX, camY);

        // Only draw visible tiles to save perf
        // Simplified culling: just draw everything for now, Fog handles logic
        for(let r=0; r<map.length; r++) {
            for(let c=0; c<map[0].length; c++) {
                const t = map[r][c];
                
                // Fog of War Check (Set lookup O(1)) - DISABLED
                // if (!this.visibleTiles.has(`${c},${r}`)) continue;
                
                const isoX = (c - r) * (TILE_SIZE / 2);
                const isoY = (c + r) * (TILE_SIZE / 4);
                
                this.drawTile(ctx, isoX, isoY, t);
                
                // SELECTION & HIGHLIGHTS
                if (this.selection) {
                    // Selection Ring
                    if (this.selection.x === c && this.selection.y === r) {
                        ctx.save();
                        ctx.strokeStyle = '#ebcb8b';
                        ctx.lineWidth = 2;
                        ctx.shadowColor = '#ebcb8b';
                        ctx.shadowBlur = 10;
                        this.drawIsoRect(ctx, isoX, isoY, TILE_SIZE);
                        ctx.restore();
                    }
                    
                    const selTile = map[this.selection.y][this.selection.x];
                    if (selTile.unit && selTile.unit.ownerId === this.peerId) {
                        const dist = Math.abs(c - this.selection.x) + Math.abs(r - this.selection.y);
                        
                        // Move Highlight (Blue) - Only if in MOVE mode
                        if (this.interactionMode === 'MOVE' && GameEngine.canMove(selTile.unit, selTile, t)) {
                            this.drawOverlay(ctx, isoX, isoY, 'rgba(136, 192, 208, 0.3)');
                        }
                        
                        // Attack Highlight (Red) - Only if in ATTACK mode
                        if (this.interactionMode === 'ATTACK') {
                            const range = UNITS[selTile.unit.type].range;
                            if (dist <= range && dist > 0) {
                                if (t.unit && t.unit.ownerId !== this.peerId) {
                                    ctx.save();
                                    ctx.fillStyle = 'rgba(191, 97, 106, 0.4)';
                                    this.drawOverlay(ctx, isoX, isoY, 'rgba(191, 97, 106, 0.4)');
                                    ctx.strokeStyle = '#bf616a';
                                    ctx.lineWidth = 2;
                                    this.drawIsoRect(ctx, isoX, isoY, TILE_SIZE);
                                    ctx.restore();
                                }
                            }
                        }
                    }
                }
                
                // HOVER CURSOR
                if (this.hoverTile && this.hoverTile.x === c && this.hoverTile.y === r) {
                    // If we have a selection, show what click will do
                    if (this.selection && (this.selection.x !== c || this.selection.y !== r)) {
                        const selTile = map[this.selection.y][this.selection.x];
                        if (selTile.unit && selTile.unit.ownerId === this.peerId) {
                            
                            if (this.interactionMode === 'MOVE' && GameEngine.canMove(selTile.unit, selTile, t)) {
                                // Valid Move Hover
                                ctx.save();
                                ctx.strokeStyle = '#88c0d0';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([5, 5]);
                                this.drawIsoRect(ctx, isoX, isoY, TILE_SIZE);
                                // Ghost Unit
                                ctx.globalAlpha = 0.5;
                                this.drawEntity(ctx, isoX, isoY - 10, UNITS[selTile.unit.type].sym, '#88c0d0', true);
                                ctx.restore();
                            } else if (this.interactionMode === 'ATTACK' && t.unit && t.unit.ownerId !== this.peerId && Math.abs(c-this.selection.x)+Math.abs(r-this.selection.y) <= UNITS[selTile.unit.type].range) {
                                // Attack Cursor
                                ctx.save();
                                ctx.strokeStyle = '#bf616a';
                                ctx.lineWidth = 3;
                                this.drawIsoRect(ctx, isoX, isoY, TILE_SIZE);
                                ctx.font = '20px Arial';
                                ctx.fillStyle = '#bf616a';
                                ctx.fillText('‚öîÔ∏è', isoX, isoY - 20);
                                ctx.restore();
                            } else {
                                // Invalid or No-Op Hover
                                ctx.save();
                                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                                ctx.lineWidth = 1;
                                this.drawIsoRect(ctx, isoX, isoY, TILE_SIZE);
                                ctx.restore();
                            }
                        }
                    } else {
                        // Just hover
                        ctx.save();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 2;
                        this.drawIsoRect(ctx, isoX, isoY, TILE_SIZE);
                        ctx.restore();
                    }
                }
            }
        }
        
        // Draw Path Line if unit has path
        // ... (Can be added later if needed, simplified hover ghost is usually enough)
        
        ctx.restore();
    },

    drawTile: function(ctx, x, y, tile) {
        const height = tile.terrain === TERRAIN.MOUNTAIN ? 20 : 5;
        
        // Top Face
        ctx.beginPath();
        ctx.moveTo(x, y - height);
        ctx.lineTo(x + TILE_SIZE/2, y + TILE_SIZE/4 - height);
        ctx.lineTo(x, y + TILE_SIZE/2 - height);
        ctx.lineTo(x - TILE_SIZE/2, y + TILE_SIZE/4 - height);
        ctx.closePath();

        if (tile.terrain === TERRAIN.WATER) {
            const grad = ctx.createLinearGradient(x, y-height, x, y+height+20);
            grad.addColorStop(0, '#5e81ac');
            grad.addColorStop(1, '#3b4252');
            ctx.fillStyle = grad;
        } else if (tile.terrain === TERRAIN.MOUNTAIN) {
             const grad = ctx.createLinearGradient(x-20, y-20, x+20, y+20);
             grad.addColorStop(0, '#4c566a');
             grad.addColorStop(1, '#2e3440');
             ctx.fillStyle = grad;
        } else {
             // Land Gradient (Texture-ish)
             const grad = ctx.createLinearGradient(x, y-height-10, x, y+height+10);
             grad.addColorStop(0, '#a3be8c');
             grad.addColorStop(1, '#8fbcbb');
             ctx.fillStyle = grad;
        }
        ctx.fill();
        
        // Apply Color Overlay for Owner
        if (tile.ownerId && tile.terrain === TERRAIN.LAND) {
             const owner = this.gameState.players.find(p => p.id === tile.ownerId);
             if(owner) {
                 ctx.fillStyle = owner.color;
                 ctx.globalAlpha = 0.3; // Thinner overlay for nicer look
                 ctx.fill();
                 ctx.globalAlpha = 1.0; // Reset
             }
        }
        
        // Border
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.stroke(); 

        // Sides (3D effect)
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        // Left Side
        ctx.beginPath();
        ctx.moveTo(x - TILE_SIZE/2, y + TILE_SIZE/4 - height);
        ctx.lineTo(x, y + TILE_SIZE/2 - height);
        ctx.lineTo(x, y + TILE_SIZE/2);
        ctx.lineTo(x - TILE_SIZE/2, y + TILE_SIZE/4);
        ctx.closePath();
        ctx.fill();
        
        // Right Side
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; // Darker
        ctx.beginPath();
        ctx.moveTo(x, y + TILE_SIZE/2 - height);
        ctx.lineTo(x + TILE_SIZE/2, y + TILE_SIZE/4 - height);
        ctx.lineTo(x + TILE_SIZE/2, y + TILE_SIZE/4);
        ctx.lineTo(x, y + TILE_SIZE/2);
        ctx.closePath();
        ctx.fill();

        if (tile.structure) {
            const isMine = tile.structure.ownerId === this.peerId;
            this.drawEntity(ctx, x, y - height - 10, STRUCTURES[tile.structure.type].sym, '#d8dee9', false, false, isMine);
        }

        if (tile.unit) {
            const u = tile.unit;
            const owner = this.gameState.players.find(p => p.id === u.ownerId);
            // Status calculation
            let status = 'READY'; // green
            if (u.movesLeft < UNITS[u.type].move) status = 'MOVED'; // yellow
            if (u.movesLeft <= 0 && u.hasAttacked) status = 'DONE'; // gray
            if (u.movesLeft <= 0 && !u.hasAttacked) status = 'MOVED_MAX'; // yellow (can attack)
            
            const isMine = u.ownerId === this.peerId;
            this.drawEntity(ctx, x, y - height - 15, UNITS[u.type].sym, owner.color, true, status, isMine);
        }
    },

    drawEntity: function(ctx, x, y, symbol, color, isUnit = false, status = 'READY', isMine = false) {
        ctx.save();
        ctx.translate(x, y);
        
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath();
        ctx.ellipse(0, 10, 12, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        if (isMine) {
            ctx.shadowColor = '#ebcb8b'; // Gold glow for own units
            ctx.shadowBlur = 15;
        }

        if (isUnit) {
            // Unit Circle Background
            // DONE = Gray, otherwise Player Color
            const bgColor = (status === 'DONE') ? '#4c566a' : color;
            
            // Gradient for "marble" look
            const grad = ctx.createRadialGradient(-3, -8, 2, 0, 0, 15);
            grad.addColorStop(0, '#fff'); // Highlight
            grad.addColorStop(0.3, bgColor);
            grad.addColorStop(1, '#2e3440'); // Shadow edge

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, -5, 14, 0, Math.PI*2);
            ctx.fill();
            
            if (isMine) {
                ctx.strokeStyle = '#ebcb8b'; // Gold border
                ctx.lineWidth = 3;
            } else {
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 1.5;
            }
            ctx.stroke();
            
            // Status Dot
            let dotColor = null;
            if (status === 'READY') dotColor = '#a3be8c'; // Green
            else if (status === 'MOVED' || status === 'MOVED_MAX') dotColor = '#ebcb8b'; // Yellow
            
            if (dotColor) {
                ctx.fillStyle = dotColor;
                ctx.beginPath();
                ctx.arc(10, -14, 4, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = '#2e3440';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
        } else {
            // Structure Base
            ctx.fillStyle = '#4c566a';
            ctx.fillRect(-12, -18, 24, 24);
            ctx.strokeStyle = '#d8dee9';
            ctx.strokeRect(-12, -18, 24, 24);
        }

        // Symbol (Emoji)
        ctx.fillStyle = '#fff';
        ctx.font = '20px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Center adjustment: Emoji baseline is weird on canvas. 
        // Translating up slightly (-5) centers it better in the circle.
        ctx.fillText(symbol, 0, -4); 

        ctx.restore();
    },
    
    drawOverlay: function(ctx, x, y, color) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + TILE_SIZE/2, y + TILE_SIZE/4);
        ctx.lineTo(x, y + TILE_SIZE/2);
        ctx.lineTo(x - TILE_SIZE/2, y + TILE_SIZE/4);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
    },

    drawIsoRect: function(ctx, x, y, size) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + size/2, y + size/4);
        ctx.lineTo(x, y + size/2);
        ctx.lineTo(x - size/2, y + size/4);
        ctx.closePath();
        ctx.stroke();
    },
    
    leaveLobby: function() {
        location.reload(); 
    }
};

window.onload = () => gameApp.init();

</script>
</body>
</html>