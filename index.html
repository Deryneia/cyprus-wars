<!-- Strategic Dominion: Cyprus Wars - v1.1.0 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategic Dominion: Cyprus Wars</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-dark: #242933;
            --text-main: #eceff4;
            --text-gold: #ebcb8b;
            --ocean-deep: #2e3440;
            --ocean-coast: #4c566a;
            --land: #a3be8c;
            --mountain: #434c5e;
            --glass-bg: rgba(0, 0, 0, 0.6);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Lato', sans-serif;
            color: var(--text-main);
            user-select: none;
        }

        h1, h2, h3, .medieval-font {
            font-family: 'Cinzel', serif;
        }

        /* Views */
        .view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
        }
        
        .view.active {
            display: flex;
        }

        /* Menu View */
        #menu-view {
            background: radial-gradient(circle at 50% 50%, #2e3440 0%, #1a1e26 100%);
            align-items: center;
            justify-content: center;
        }

        .menu-card {
            background: rgba(30, 35, 45, 0.9);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 16px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            max-width: 800px; /* Widen for improved Lobby */
            width: 90%;
            text-align: center;
        }

        .title-gradient {
            background: linear-gradient(to right, #ebcb8b, #d08770);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 3rem;
            margin: 0 0 10px 0;
        }

        input, select {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #4c566a;
            color: white;
            padding: 10px;
            border-radius: 8px;
            width: 100%;
            margin-bottom: 15px;
            box-sizing: border-box;
            font-family: 'Lato', sans-serif;
        }

        button {
            background: linear-gradient(135deg, #5e81ac, #81a1c1);
            border: none;
            padding: 12px 24px;
            color: white;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            font-family: 'Cinzel', serif;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(94, 129, 172, 0.5);
        }

        button.secondary {
            background: #434c5e;
        }
        
        button.danger {
            background: #bf616a;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            text-align: left;
        }

        /* Lobby View */
        #lobby-view {
            background: #242933;
            align-items: center;
            justify-content: center;
        }
        
        .player-list {
            margin: 20px 0;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
        }

        .player-item {
            display: grid;
            grid-template-columns: 40px 2fr 1fr 1fr 40px;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-bottom: 1px solid #4c566a;
            text-align: left;
        }
        
        .player-item select {
            margin-bottom: 0;
            padding: 5px;
        }

        /* Game View */
        #game-view {
            position: relative;
        }

        canvas {
            display: block;
            background: #1a1e26;
        }

        /* HUD */
        #hud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass to canvas */
        }

        .hud-panel {
            position: absolute;
            background: var(--glass-bg);
            backdrop-filter: blur(5px);
            border: 1px solid var(--glass-border);
            padding: 10px;
            pointer-events: auto;
            border-radius: 8px;
        }

        #top-bar {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
        }

        #bottom-left {
            bottom: 10px;
            left: 10px;
            width: 300px;
            height: 200px;
            overflow-y: auto;
            font-size: 0.9rem;
        }

        #bottom-right {
            bottom: 10px;
            right: 10px;
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 2px;
        }

        .action-btn {
            width: 100%;
            margin-bottom: 5px;
            font-size: 0.8rem;
            padding: 8px;
        }

        .resource-display {
            color: var(--text-gold);
            font-weight: bold;
        }

        .modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: auto;
        }
        
        .hidden { display: none !important; }

        .tech-tree-node {
            padding: 10px;
            border: 1px solid #88c0d0;
            margin: 5px;
            cursor: pointer;
        }
        .tech-tree-node.unlocked { background: #5e81ac; }
        .tech-tree-node.locked { background: #2e3440; color: #666; }

        #loading-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            flex-direction: column;
        }
        
        .unit-stats { font-size: 0.8em; color: #bbb; }
    </style>
</head>
<body>

<!-- Loading / Peer Init -->
<div id="loading-overlay">
    <h2 class="medieval-font">Initializing Comms...</h2>
    <div id="init-status">Connecting to Network...</div>
</div>

<!-- Menu View -->
<div id="menu-view" class="view active">
    <div class="menu-card">
        <h1 class="title-gradient medieval-font">Strategic Dominion</h1>
        <h2 style="color: #88c0d0; letter-spacing: 4px; margin-bottom: 30px;">CYPRUS WARS</h2>
        
        <div class="grid-2">
            <div style="border-right: 1px solid #4c566a; padding-right: 20px;">
                <h3 class="medieval-font">Profile</h3>
                <label>Name</label>
                <input type="text" id="player-name" value="Commander">
            </div>
            
            <div style="display: flex; flex-direction: column; justify-content: center;">
                <button onclick="gameApp.hostGame()">Create Campaign</button>
                <div style="margin: 15px 0; font-size: 0.8rem; color: #888;">- OR -</div>
                <input type="text" id="host-id-input" placeholder="Enter Host ID">
                <button class="secondary" onclick="gameApp.joinGame()">Join Campaign</button>
            </div>
        </div>
        
        <div style="margin-top: 20px; font-size: 0.8rem; color: #666;">
            Your ID: <span id="my-peer-id" style="color: #88c0d0; user-select: all;">...</span>
        </div>
    </div>
</div>

<!-- Lobby View -->
<div id="lobby-view" class="view">
    <div class="menu-card">
        <h2 class="medieval-font">Mission Lobby</h2>
        
        <!-- Slot Config -->
        <div class="player-list" id="lobby-slots"></div>
        
        <div id="host-controls" class="hidden">
            <button onclick="gameApp.addSlot()" style="margin-bottom: 10px; font-size: 0.8rem;">+ Add AI / Slot</button>
            
            <h3 class="medieval-font">Map Settings</h3>
            <select id="map-type">
                <option value="SIMPLE_SQUARE">Simple Square (Test)</option>
                <option value="CYPRUS">Cyprus (Historic)</option>
                <option value="RANDOM">Archipelago (Random)</option>
            </select>
            <br><br>
            <button onclick="gameApp.startGame()">Deploy Units</button>
        </div>
        <div id="client-controls" class="hidden">
            <p>Waiting for Host to Start...</p>
        </div>
        <br>
        <button class="secondary" onclick="gameApp.leaveLobby()">Back</button>
    </div>
</div>

<!-- Game View -->
<div id="game-view" class="view">
    <canvas id="game-canvas"></canvas>
    
    <div id="hud-layer">
        <!-- Top Bar -->
        <div id="top-bar" class="hud-panel">
            <div class="medieval-font" id="turn-indicator">Turn 1</div>
            <div id="timer" style="color: #d08770; font-weight: bold;">45s</div>
            <div>Gold: <span id="gold-display" class="resource-display">0</span></div>
            <div>Income: <span id="income-display" class="resource-display">+0</span></div>
        </div>

        <!-- Log -->
        <div id="bottom-left" class="hud-panel">
            <div id="game-log"></div>
        </div>

        <!-- Controls -->
        <div id="bottom-right" class="hud-panel">
            <div id="selection-panel">
                <h3 class="medieval-font" id="selection-title" style="margin: 0 0 10px 0;">No Selection</h3>
                <div id="selection-details" style="font-size: 0.8rem; margin-bottom: 10px;"></div>
                <div id="action-buttons"></div>
            </div>
            <div style="border-top: 1px solid #666; margin-top: 5px; padding-top: 5px;">
                <button class="action-btn" onclick="gameApp.toggleTechTree()">Research</button>
                <button class="action-btn" style="background: #bf616a;" onclick="gameApp.endTurn()">End Turn</button>
            </div>
        </div>
    </div>

    <!-- Tech Tree Modal -->
    <div id="tech-modal" class="modal hidden">
        <div class="menu-card" style="max-width: 800px;">
            <h2 class="medieval-font">Technology Research</h2>
            <div id="tech-tree-container" style="display: flex; flex-wrap: wrap; justify-content: center;"></div>
            <button class="secondary" onclick="gameApp.toggleTechTree()">Close</button>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal hidden">
        <div class="menu-card">
            <h1 class="medieval-font" id="winner-title">Victory!</h1>
            <p id="winner-message">The enemy has been vanquished.</p>
            <button onclick="location.reload()">Return to Menu</button>
        </div>
    </div>
</div>

<script>
/**
 * CONSTANTS & CONFIG
 */
const TILE_SIZE = 64; 
const MAP_SIZE = 18;
const TURN_TIME = 45; // Seconds

const FACTION_INFO = {
    PEASANT_REBELLION: "Peasants cost -1 Gold.",
    TECHNOLOGISTS: "Tech costs 30% less.",
    ORDER_OF_KNIGHTS: "Knights -1 Gold, but Knight Tech cost +50%.",
    MARITIME_MERCHANTS: "Boats cost -1 Gold."
};

const FACTION_COLORS = ['#bf616a', '#d08770', '#ebcb8b', '#a3be8c', '#b48ead'];
const FACTION_TYPES = Object.keys(FACTION_INFO);

const TERRAIN = {
    WATER: 0,
    LAND: 1,
    MOUNTAIN: 2
};

const UNITS = {
    PEASANT: { name: "Peasant", cost: 2, atk: 1, def: 1, range: 1, move: 1, sym: "P" },
    ARCHER: { name: "Archer", cost: 3, atk: 1, def: 1, range: 2, move: 1, sym: "A" },
    KNIGHT: { name: "Knight", cost: 4, atk: 1, def: 2, range: 1, move: 2, sym: "K" }, // Requires Iron
    CATAPULT: { name: "Catapult", cost: 5, atk: 1, def: 5, range: 3, move: 1, sym: "C" },
    TRADE_BOAT: { name: "Trade Boat", cost: 5, atk: 0, def: 1, range: 0, move: 1, sym: "T" },
    WAR_BOAT: { name: "War Boat", cost: 10, atk: 2, def: 1, range: 1, move: 1, sym: "W" }
};

const STRUCTURES = {
    CAPITAL: { name: "Capital", hp: 30, sym: "★" },
    FORT: { name: "Fort", hp: 10, sym: "♜" },
    DOCK: { name: "Dock", hp: 10, sym: "⚓" },
    MINE_GOLD: { name: "Gold Mine", hp: 5, sym: "G" },
    MINE_IRON: { name: "Iron Mine", hp: 5, sym: "Fe" }
};

const TECHS = {
    ARCHERY: { name: "Archery", cost: 10, unlocks: "ARCHER" },
    CHIVALRY: { name: "Chivalry", cost: 20, unlocks: "KNIGHT", reqRes: "IRON" },
    SIEGE: { name: "Siegecraft", cost: 30, unlocks: "CATAPULT", reqRes: "IRON" },
    FARMING: { name: "Farming", cost: 20, desc: "+Income" },
    FISHING: { name: "Fishing", cost: 20, desc: "Unlocks Docks" },
    BANKING: { name: "Banking", cost: 40, desc: "+Interest" }
};

/**
 * GAME ENGINE SERVICES
 */
class GameEngine {
    static createInitialState(config, lobbySlots) {
        const map = this.generateMap(config.mapType);
        // Create Players from Lobby Slots
        const players = lobbySlots.map((slot, i) => ({
            id: slot.id || `ai_${i}`,
            name: slot.name,
            type: slot.type, // HUMAN or CPU
            difficulty: slot.difficulty || 'MEDIUM',
            faction: slot.faction,
            color: FACTION_COLORS[i % FACTION_COLORS.length],
            isAlive: true,
            gold: 10,
            techs: []
        }));

        const spawnPoints = this.getSpawnPoints(map, players.length);
        
        players.forEach((p, i) => {
            const sp = spawnPoints[i];
            if(sp) {
                map[sp.y][sp.x].structure = { type: 'CAPITAL', hp: 30, ownerId: p.id };
                map[sp.y][sp.x].ownerId = p.id;
                // Initial Unit
                map[sp.y][sp.x].unit = {
                    id: `u_${Math.random()}`,
                    type: 'PEASANT',
                    ownerId: p.id,
                    hp: 1, maxHp: 1, movesLeft: 1, hasAttacked: false
                };
            }
        });

        return {
            map,
            players,
            currentPlayerIndex: 0,
            turn: 1,
            phase: 'PLAYING',
            logs: ["Game Started. Welcome Commanders."],
            timeLeft: TURN_TIME
        };
    }

    static generateMap(type) {
        const map = [];
        for (let y = 0; y < MAP_SIZE; y++) {
            const row = [];
            for (let x = 0; x < MAP_SIZE; x++) {
                row.push({ x, y, terrain: TERRAIN.WATER, ownerId: null, unit: null, structure: null });
            }
            map.push(row);
        }

        if (type === 'SIMPLE_SQUARE') {
            // 12x12 Green Square in middle
            const inset = 3;
            for (let y = inset; y < MAP_SIZE - inset; y++) {
                for (let x = inset; x < MAP_SIZE - inset; x++) {
                    map[y][x].terrain = TERRAIN.LAND;
                }
            }
        } else if (type === 'CYPRUS') {
            const cx = MAP_SIZE / 2;
            const cy = MAP_SIZE / 2;
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const dx = (x - cx) * 1.2;
                    const dy = (y - cy) * 2.0;
                    if (Math.sqrt(dx*dx + dy*dy) < 7) {
                        map[y][x].terrain = TERRAIN.LAND;
                        if (Math.abs(x - cx) < 2 && Math.abs(y - cy) < 1.5) {
                            map[y][x].terrain = TERRAIN.MOUNTAIN;
                        }
                    }
                }
            }
            for(let x = 14; x < 17; x++) {
                if(map[3] && map[3][x]) map[3][x].terrain = TERRAIN.LAND;
            }
        } else {
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (Math.random() > 0.6) map[y][x].terrain = TERRAIN.LAND;
                    if (map[y][x].terrain === TERRAIN.LAND && Math.random() > 0.9) map[y][x].terrain = TERRAIN.MOUNTAIN;
                }
            }
        }
        return map;
    }

    static getSpawnPoints(map, count) {
        const points = [];
        // TL, BR, TR, BL, Center
        points.push(this.findLand(map, 0, 0, 1, 1));
        points.push(this.findLand(map, MAP_SIZE-1, MAP_SIZE-1, -1, -1));
        points.push(this.findLand(map, MAP_SIZE-1, 0, -1, 1));
        points.push(this.findLand(map, 0, MAP_SIZE-1, 1, -1));
        points.push(this.findLand(map, MAP_SIZE/2, MAP_SIZE/2, 1, 1));
        return points.slice(0, count);
    }

    static findLand(map, startX, startY, dx, dy) {
        let x = startX, y = startY;
        x = Math.max(0, Math.min(MAP_SIZE-1, x));
        y = Math.max(0, Math.min(MAP_SIZE-1, y));
        
        let maxIter = 100;
        while(maxIter-- > 0) {
            if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
                if (map[Math.floor(y)][Math.floor(x)].terrain === TERRAIN.LAND) {
                    return {x: Math.floor(x), y: Math.floor(y)};
                }
                x += dx;
                if (x < 0 || x >= MAP_SIZE) {
                    x = startX;
                    y += dy;
                }
            } else break;
        }
        return {x: Math.floor(startX), y: Math.floor(startY)};
    }

    static canMove(unit, fromTile, toTile) {
        if (unit.movesLeft <= 0) return false;
        if (toTile.unit) return false; 
        
        const dx = Math.abs(fromTile.x - toTile.x);
        const dy = Math.abs(fromTile.y - toTile.y);
        const dist = dx + dy; 
        
        if (dist > unit.move) return false; 

        const isBoat = unit.type.includes('BOAT');
        if (isBoat && toTile.terrain !== TERRAIN.WATER) return false;
        if (!isBoat && toTile.terrain === TERRAIN.WATER && !toTile.structure) return false; 
        if (toTile.terrain === TERRAIN.MOUNTAIN) return false; 

        return true;
    }
    
    static nextTurn(state) {
        let nextIdx = (state.currentPlayerIndex + 1) % state.players.length;
        let loopGuard = 0;
        while(!state.players[nextIdx].isAlive && loopGuard < state.players.length) {
            nextIdx = (nextIdx + 1) % state.players.length;
            loopGuard++;
        }
        
        state.currentPlayerIndex = nextIdx;
        if (nextIdx === 0) state.turn++;
        state.timeLeft = TURN_TIME; // Reset Timer

        const player = state.players[nextIdx];
        
        // Reset Units
        for (let row of state.map) {
            for (let tile of row) {
                if (tile.unit && tile.unit.ownerId === player.id) {
                    tile.unit.movesLeft = UNITS[tile.unit.type].move;
                    tile.unit.hasAttacked = false;
                }
            }
        }

        // Income
        let income = 0;
        for (let row of state.map) {
            for (let tile of row) {
                if (tile.ownerId === player.id) income += 0.5;
                if (tile.structure && tile.structure.ownerId === player.id && tile.structure.type === 'MINE_GOLD') income += 5;
            }
        }
        if (player.techs.includes('FARMING')) income += 5;
        if (player.techs.includes('BANKING')) income += Math.floor(player.gold * 0.05);

        player.gold += Math.floor(income);
        state.logs.unshift(`Turn ${state.turn}: ${player.name}'s turn. Income: ${Math.floor(income)}`);
        
        return state;
    }
}

/**
 * AI LOGIC
 */
class AIPlayer {
    static processTurn(app, gameState) {
        const player = gameState.players[gameState.currentPlayerIndex];
        if (player.type !== 'CPU') return;

        console.log(`AI ${player.name} thinking...`);
        
        // 1. Move Units
        // Simple logic: Move towards enemy capital or unit
        const myUnits = [];
        for(let r=0; r<MAP_SIZE; r++) {
            for(let c=0; c<MAP_SIZE; c++) {
                if(gameState.map[r][c].unit && gameState.map[r][c].unit.ownerId === player.id) {
                    myUnits.push({x: c, y: r, u: gameState.map[r][c].unit});
                }
            }
        }

        myUnits.forEach(unitData => {
            if(unitData.u.movesLeft > 0) {
                this.tryMoveAI(app, unitData, gameState);
            }
        });

        // 2. Buy Units
        if (player.gold >= 2) {
             // Simple: buy peasant if possible
             app.buyUnit('PEASANT');
        }

        // 3. End Turn
        setTimeout(() => app.endTurn(), 1500); // Small delay for "thinking"
    }

    static tryMoveAI(app, unitData, state) {
        // Try random adjacent move for now (Placeholder for A*)
        const dx = [0, 0, 1, -1];
        const dy = [1, -1, 0, 0];
        
        for(let i=0; i<4; i++) {
            const nx = unitData.x + dx[i];
            const ny = unitData.y + dy[i];
            if(nx>=0 && nx<MAP_SIZE && ny>=0 && ny<MAP_SIZE) {
                const target = state.map[ny][nx];
                // Just try to capture empty land
                if(GameEngine.canMove(unitData.u, state.map[unitData.y][unitData.x], target)) {
                    // If enemy, attack
                    if(target.unit && target.unit.ownerId !== unitData.u.ownerId) {
                        app.sendAction({ type: 'ATTACK', from: {x: unitData.x, y: unitData.y}, to: {x: nx, y: ny} });
                        return;
                    }
                    // If empty land, move
                    if(!target.unit && target.terrain === TERRAIN.LAND) {
                        app.sendAction({ type: 'MOVE', from: {x: unitData.x, y: unitData.y}, to: {x: nx, y: ny} });
                        return;
                    }
                }
            }
        }
    }
}

/**
 * APP LOGIC
 */
const gameApp = {
    peer: null,
    conn: null,
    peerId: null,
    gameState: null,
    lobbySlots: [], // Changed from lobbyPlayers to slots
    isHost: false,
    view: 'MENU', 
    selection: null,
    turnTimerInterval: null,

    // Setup
    init: function() {
        this.peer = new Peer(null, { debug: 2 });
        this.peer.on('open', (id) => {
            this.peerId = id;
            document.getElementById('my-peer-id').innerText = id;
            document.getElementById('loading-overlay').classList.add('hidden');
        });
        
        this.peer.on('connection', (c) => {
            this.setupConnection(c);
        });

        // Canvas Events
        const canvas = document.getElementById('game-canvas');
        canvas.addEventListener('mousedown', (e) => this.handleCanvasClick(e));
        window.addEventListener('resize', () => this.resizeCanvas());

        // Timer Loop
        setInterval(() => this.gameLoop(), 1000);
    },

    setupConnection: function(c) {
        c.on('data', (data) => this.handleNetworkMessage(data, c));
        c.on('open', () => {
            if (this.isHost) {
                c.send({ type: 'LOBBY_UPDATE', slots: this.lobbySlots });
            }
        });
        if (this.isHost && !this.connections) this.connections = [];
        if (this.isHost) this.connections.push(c);
        else this.conn = c; 
    },

    handleNetworkMessage: function(msg, sender) {
        switch(msg.type) {
            case 'JOIN_REQUEST':
                if(this.isHost) {
                    // Find first empty HUMAN slot
                    const emptySlotIdx = this.lobbySlots.findIndex(s => s.type === 'HUMAN' && !s.id);
                    if (emptySlotIdx !== -1) {
                        this.lobbySlots[emptySlotIdx] = {
                            ...this.lobbySlots[emptySlotIdx],
                            id: sender.peer,
                            name: msg.player.name,
                            ready: true
                        };
                        this.broadcast({ type: 'LOBBY_UPDATE', slots: this.lobbySlots });
                    }
                }
                break;
            case 'LOBBY_UPDATE':
                this.lobbySlots = msg.slots;
                this.renderLobby();
                break;
            case 'SYNC_STATE':
                this.gameState = msg.state;
                if (this.view !== 'GAME') this.switchView('GAME');
                this.renderGame();
                this.updateHUD();
                break;
        }
    },

    broadcast: function(msg) {
        if (this.isHost && this.connections) {
            this.connections.forEach(c => c.send(msg));
            if(msg.type === 'SYNC_STATE') this.gameState = msg.state;
        } else if (this.conn) {
            this.conn.send(msg); 
        }
    },

    // Actions
    hostGame: function() {
        this.isHost = true;
        // Initial Slot (Host)
        this.lobbySlots = [{
            id: this.peerId,
            name: document.getElementById('player-name').value,
            type: 'HUMAN',
            faction: 'PEASANT_REBELLION',
            ready: true
        }];
        // Add one AI by default
        this.addSlot();
        
        this.switchView('LOBBY');
        this.renderLobby();
    },

    joinGame: function() {
        const hostId = document.getElementById('host-id-input').value;
        if(!hostId) return alert("Enter Host ID");
        
        this.isHost = false;
        const conn = this.peer.connect(hostId);
        this.setupConnection(conn);
        
        conn.on('open', () => {
            conn.send({
                type: 'JOIN_REQUEST',
                player: {
                    name: document.getElementById('player-name').value
                }
            });
            this.switchView('LOBBY');
        });
    },

    addSlot: function() {
        if(this.lobbySlots.length >= 5) return;
        this.lobbySlots.push({
            id: null,
            name: `AI Player ${this.lobbySlots.length}`,
            type: 'CPU',
            difficulty: 'MEDIUM',
            faction: FACTION_TYPES[this.lobbySlots.length % FACTION_TYPES.length],
            ready: true
        });
        this.broadcast({ type: 'LOBBY_UPDATE', slots: this.lobbySlots });
        this.renderLobby();
    },
    
    updateSlot: function(idx, field, value) {
        if(!this.isHost) return;
        this.lobbySlots[idx][field] = value;
        this.broadcast({ type: 'LOBBY_UPDATE', slots: this.lobbySlots });
        this.renderLobby();
    },
    
    removeSlot: function(idx) {
        if(!this.isHost) return;
        this.lobbySlots.splice(idx, 1);
        this.broadcast({ type: 'LOBBY_UPDATE', slots: this.lobbySlots });
        this.renderLobby();
    },

    startGame: function() {
        if(!this.isHost) return;
        const config = { mapType: document.getElementById('map-type').value };
        const initialState = GameEngine.createInitialState(config, this.lobbySlots);
        this.gameState = initialState;
        this.broadcast({ type: 'SYNC_STATE', state: initialState });
        this.switchView('GAME');
        this.resizeCanvas();
        this.renderGame();
    },

    gameLoop: function() {
        if (!this.gameState || !this.isHost) return;
        
        // Timer Logic
        if (this.gameState.timeLeft > 0) {
            this.gameState.timeLeft--;
        } else {
            this.endTurn(); // Force end turn
            return;
        }
        
        // Broadcast timer update every second (optimized: could be local but sync helps)
        // To avoid spamming, we assume clients decrement locally and we just sync on turn change,
        // BUT for strict enforcement host sends state. 
        // For this demo, we will just update local UI and sync state on significant events, 
        // or rely on clients trusting the host's "End Turn" signal.
        
        // AI Turn
        const currP = this.gameState.players[this.gameState.currentPlayerIndex];
        if (currP.type === 'CPU') {
            // Throttle AI calls
            if (Math.random() > 0.8) AIPlayer.processTurn(this, this.gameState);
        }

        this.updateHUD();
    },

    switchView: function(viewName) {
        this.view = viewName;
        document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
        if(viewName === 'MENU') document.getElementById('menu-view').classList.add('active');
        if(viewName === 'LOBBY') document.getElementById('lobby-view').classList.add('active');
        if(viewName === 'GAME') document.getElementById('game-view').classList.add('active');

        if(viewName === 'LOBBY') {
            if(this.isHost) {
                document.getElementById('host-controls').classList.remove('hidden');
                document.getElementById('client-controls').classList.add('hidden');
            } else {
                document.getElementById('host-controls').classList.add('hidden');
                document.getElementById('client-controls').classList.remove('hidden');
            }
        }
    },

    renderLobby: function() {
        const list = document.getElementById('lobby-slots');
        list.innerHTML = '';
        
        this.lobbySlots.forEach((slot, idx) => {
            const div = document.createElement('div');
            div.className = 'player-item';
            
            // Color indicator
            const color = FACTION_COLORS[idx % FACTION_COLORS.length];
            
            // Slot Type Selector (Host only)
            const typeSelect = this.isHost ? `
                <select onchange="gameApp.updateSlot(${idx}, 'type', this.value)">
                    <option value="HUMAN" ${slot.type==='HUMAN'?'selected':''}>Human</option>
                    <option value="CPU" ${slot.type==='CPU'?'selected':''}>CPU</option>
                </select>
            ` : slot.type;
            
             // Faction Selector (Host only)
            const factionSelect = this.isHost ? `
                <select onchange="gameApp.updateSlot(${idx}, 'faction', this.value)">
                    ${FACTION_TYPES.map(f => `<option value="${f}" ${slot.faction===f?'selected':''}>${f}</option>`).join('')}
                </select>
            ` : slot.faction;

            // Name (Editable if CPU)
            const nameDisplay = (slot.type === 'CPU' && this.isHost) 
                ? `<input type="text" value="${slot.name}" onchange="gameApp.updateSlot(${idx}, 'name', this.value)" style="margin:0;padding:5px;">` 
                : `<span>${slot.name} ${slot.id ? '(Connected)' : '(Waiting...)'}</span>`;

            // Remove button (Host only, not for self)
            const removeBtn = (this.isHost && idx !== 0) 
                ? `<button class="danger" onclick="gameApp.removeSlot(${idx})" style="padding:5px; font-size:0.8rem;">X</button>` 
                : ``;

            div.innerHTML = `
                <div style="width:20px;height:20px;border-radius:50%;background:${color}"></div>
                ${nameDisplay}
                ${typeSelect}
                ${factionSelect}
                ${removeBtn}
            `;
            list.appendChild(div);
        });
    },

    // GAMEPLAY WRAPPERS
    handleCanvasClick: function(e) { 
        // Prevent clicks if CPU turn
        const p = this.gameState.players[this.gameState.currentPlayerIndex];
        if (p.type === 'CPU') return;
        
        // Prevent clicks if not your turn (unless host debugging)
        if (p.id !== this.peerId) return;

        // Call engine logic (same as before)
        // ... (Copy logic from v1.0 but simplified for brevity in this prompt, full logic below)
        this.doTileClickLogic(e);
    },
    
    doTileClickLogic: function(e) {
        // ... (Logic moved to separate function to keep cleaner)
         if (!this.gameState) return;
        const rect = e.target.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const offsetX = e.target.width / 2;
        const offsetY = 100;
        let bestTile = null;
        let minDst = 9999;

        for(let r=0; r<this.gameState.map.length; r++) {
            for(let c=0; c<this.gameState.map[0].length; c++) {
                const t = this.gameState.map[r][c];
                const tx = (c - r) * (TILE_SIZE / 2) + offsetX;
                const ty = (c + r) * (TILE_SIZE / 4) + offsetY;
                const dist = Math.sqrt(Math.pow(screenX - tx, 2) + Math.pow(screenY - ty, 2));
                if (dist < TILE_SIZE/2 && dist < minDst) {
                    minDst = dist;
                    bestTile = t;
                }
            }
        }
        if (bestTile) this.onTileInteraction(bestTile.x, bestTile.y);
    },

    onTileInteraction: function(x, y) {
         const state = this.gameState;
        const currentPlayer = state.players[state.currentPlayerIndex];
        
        // Only allow current player to act
        if (currentPlayer.id !== this.peerId) return;

        const targetTile = state.map[y][x];
        const clickedUnit = targetTile.unit;

        // State machine for selection
        if (this.selection) {
            const prevTile = state.map[this.selection.y][this.selection.x];
            const selectedUnit = prevTile.unit;
            
            // Move Logic
            if (GameEngine.canMove(selectedUnit, prevTile, targetTile)) {
                // Send Move Action
                this.sendAction({ type: 'MOVE', from: {x: this.selection.x, y: this.selection.y}, to: {x, y} });
                this.selection = null;
            }
            // Attack Logic
            else if (clickedUnit && clickedUnit.ownerId !== this.peerId) {
                 const dist = Math.abs(x - this.selection.x) + Math.abs(y - this.selection.y);
                 if (dist <= UNITS[selectedUnit.type].range && !selectedUnit.hasAttacked) {
                     this.sendAction({ type: 'ATTACK', from: {x: this.selection.x, y: this.selection.y}, to: {x, y} });
                     this.selection = null;
                 } else {
                     if(clickedUnit.ownerId === this.peerId) this.selection = {x, y};
                     else this.selection = null;
                 }
            }
            else {
                if(clickedUnit && clickedUnit.ownerId === this.peerId) this.selection = {x, y};
                else this.selection = null;
            }
        } else {
            if (clickedUnit && clickedUnit.ownerId === this.peerId) {
                this.selection = {x, y};
            }
        }
        this.renderGame();
        this.updateHUD();
    },

    sendAction: function(action) {
        // Clone state
        const newState = JSON.parse(JSON.stringify(this.gameState));
        const player = newState.players[newState.currentPlayerIndex];
        
        // ... (Same Logic as v1.0 but added here for completeness)
        if (action.type === 'MOVE') {
            const u = newState.map[action.from.y][action.from.x].unit;
            newState.map[action.to.y][action.to.x].unit = u;
            newState.map[action.from.y][action.from.x].unit = null;
            u.movesLeft -= 1;
            if (newState.map[action.to.y][action.to.x].terrain === TERRAIN.LAND) {
                newState.map[action.to.y][action.to.x].ownerId = player.id;
            }
            newState.logs.unshift(`${player.name} moved ${UNITS[u.type].name}`);
        }
        if (action.type === 'ATTACK') {
            const attacker = newState.map[action.from.y][action.from.x].unit;
            const defender = newState.map[action.to.y][action.to.x].unit;
            const dmg = Math.max(0, UNITS[attacker.type].atk - (UNITS[defender.type].def * 0.1)); 
            let finalDmg = 1; 
            if(attacker.type === 'KNIGHT' && defender.type === 'ARCHER') finalDmg = 2;
            if(attacker.type === 'ARCHER' && defender.type === 'PEASANT') finalDmg = 1;
            defender.hp -= finalDmg;
            attacker.hasAttacked = true;
            attacker.movesLeft = 0;
            newState.logs.unshift(`${player.name}'s ${UNITS[attacker.type].name} hit ${UNITS[defender.type].name} for ${finalDmg} dmg!`);
            if (defender.hp <= 0) {
                 newState.map[action.to.y][action.to.x].unit = null;
                 newState.logs.unshift(`Enemy unit destroyed!`);
            }
        }
        if (action.type === 'END_TURN') GameEngine.nextTurn(newState);
        if (action.type === 'BUY_UNIT') {
             let spawned = false;
             const cost = UNITS[action.unitType].cost;
             let actualCost = cost;
             if (player.faction === 'PEASANT_REBELLION' && action.unitType === 'PEASANT') actualCost -= 1;
             if (player.faction === 'MARITIME_MERCHANTS' && action.unitType.includes('BOAT')) actualCost -= 1;
             if (player.faction === 'ORDER_OF_KNIGHTS' && action.unitType === 'KNIGHT') actualCost -= 1;
             
             if (player.gold >= actualCost) {
                 for(let r=0; r<MAP_SIZE; r++) {
                     for(let c=0; c<MAP_SIZE; c++) {
                         const t = newState.map[r][c];
                         if(t.ownerId === player.id && !t.unit && t.structure) {
                             const isWater = action.unitType.includes('BOAT');
                             const isDock = t.structure.type === 'DOCK';
                             if(isWater === isDock || (!isWater && !isDock)) {
                                 t.unit = {
                                     id: `u_${Math.random()}`,
                                     type: action.unitType,
                                     ownerId: player.id,
                                     hp: 5, maxHp: 5, movesLeft: 0, hasAttacked: true
                                 };
                                 player.gold -= actualCost;
                                 spawned = true;
                                 break;
                             }
                         }
                     }
                     if(spawned) break;
                 }
                 if(spawned) newState.logs.unshift(`${player.name} recruited ${action.unitType}`);
             } 
        }

        this.gameState = newState;
        this.broadcast({ type: 'SYNC_STATE', state: newState });
        this.renderGame();
        this.updateHUD();
    },

    endTurn: function() {
        this.sendAction({ type: 'END_TURN' });
    },
    
    buyUnit: function(type) {
        this.sendAction({ type: 'BUY_UNIT', unitType: type });
    },

    updateHUD: function() {
        if (!this.gameState) return;
        const myPlayer = this.gameState.players.find(p => p.id === this.peerId) || this.gameState.players[0];
        const turnPlayer = this.gameState.players[this.gameState.currentPlayerIndex];
        
        document.getElementById('turn-indicator').innerText = `Turn ${this.gameState.turn} - ${turnPlayer.name}`;
        document.getElementById('timer').innerText = `${this.gameState.timeLeft}s`;
        document.getElementById('gold-display').innerText = myPlayer ? myPlayer.gold : 0;
        
        // Logs
        const logDiv = document.getElementById('game-log');
        logDiv.innerHTML = this.gameState.logs.slice(0, 10).map(l => `<div class="log-entry">${l}</div>`).join('');
        
        // Selection
        const selPanel = document.getElementById('selection-panel');
        const selTitle = document.getElementById('selection-title');
        const selDetails = document.getElementById('selection-details');
        const actionBtns = document.getElementById('action-buttons');
        
        actionBtns.innerHTML = '';
        
        // Only show controls if it's MY turn and I am Human
        const isMyTurn = (turnPlayer.id === this.peerId);

        if (this.selection) {
            const tile = this.gameState.map[this.selection.y][this.selection.x];
            if (tile.unit) {
                const uInfo = UNITS[tile.unit.type];
                selTitle.innerText = uInfo.name;
                selDetails.innerHTML = `HP: ${tile.unit.hp} | Move: ${tile.unit.movesLeft}`;
            } else if (tile.structure) {
                const sInfo = STRUCTURES[tile.structure.type];
                selTitle.innerText = sInfo.name;
                selDetails.innerHTML = "Structure";
                // Recruitment
                if(tile.ownerId === this.peerId && isMyTurn) {
                    if (tile.structure.type === 'CAPITAL' || tile.structure.type === 'FORT') {
                         ['PEASANT', 'ARCHER', 'KNIGHT', 'CATAPULT'].forEach(ut => {
                             const btn = document.createElement('button');
                             btn.className = 'action-btn';
                             btn.innerText = `Recruit ${UNITS[ut].name} (${UNITS[ut].cost}g)`;
                             btn.onclick = () => this.buyUnit(ut);
                             actionBtns.appendChild(btn);
                         });
                    }
                }
            } else {
                selTitle.innerText = "Empty Tile";
                selDetails.innerHTML = "";
            }
        } else {
            selTitle.innerText = "No Selection";
            selDetails.innerHTML = "Select a unit or structure.";
        }
    },
    
    toggleTechTree: function() {
        document.getElementById('tech-modal').classList.toggle('hidden');
        this.renderTechTree();
    },
    
    renderTechTree: function() {
        const container = document.getElementById('tech-tree-container');
        container.innerHTML = '';
        Object.keys(TECHS).forEach(k => {
            const t = TECHS[k];
            const div = document.createElement('div');
            div.className = 'tech-tree-node';
            div.innerHTML = `<strong>${t.name}</strong><br>${t.cost}g`;
            container.appendChild(div);
        });
    },

    // RENDERER
    resizeCanvas: function() {
        const cvs = document.getElementById('game-canvas');
        cvs.width = window.innerWidth;
        cvs.height = window.innerHeight;
        this.renderGame();
    },

    renderGame: function() {
        if(!this.gameState) return;
        const cvs = document.getElementById('game-canvas');
        const ctx = cvs.getContext('2d');
        ctx.clearRect(0, 0, cvs.width, cvs.height);

        const map = this.gameState.map;
        const offsetX = cvs.width / 2;
        const offsetY = 100;

        // Render Map
        for(let r=0; r<map.length; r++) {
            for(let c=0; c<map[0].length; c++) {
                const t = map[r][c];
                // Isometric Projection
                const isoX = (c - r) * (TILE_SIZE / 2) + offsetX;
                const isoY = (c + r) * (TILE_SIZE / 4) + offsetY;
                
                this.drawTile(ctx, isoX, isoY, t);
                
                // Highlight Selection
                if (this.selection && this.selection.x === c && this.selection.y === r) {
                    ctx.save();
                    ctx.strokeStyle = '#ebcb8b';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#ebcb8b';
                    ctx.shadowBlur = 10;
                    this.drawIsoRect(ctx, isoX, isoY, TILE_SIZE);
                    ctx.restore();
                }
            }
        }
    },

    drawTile: function(ctx, x, y, tile) {
        // Colors
        let baseColor;
        if (tile.terrain === TERRAIN.WATER) baseColor = '#2e3440'; // Deep Ocean
        else if (tile.terrain === TERRAIN.MOUNTAIN) baseColor = '#434c5e'; // Mountain
        else baseColor = '#a3be8c'; // Land

        // Owner Tint
        if (tile.ownerId) {
            const owner = this.gameState.players.find(p => p.id === tile.ownerId);
            if (owner && tile.terrain === TERRAIN.LAND) {
                // simple tint
            }
        }

        // Draw Block (Extrusion)
        const height = tile.terrain === TERRAIN.MOUNTAIN ? 20 : 5;
        
        // Top Face
        ctx.fillStyle = baseColor;
        if (tile.terrain === TERRAIN.WATER) {
            const grad = ctx.createLinearGradient(x, y-10, x, y+10);
            grad.addColorStop(0, '#4c566a');
            grad.addColorStop(1, '#2e3440');
            ctx.fillStyle = grad;
        }
        
        ctx.beginPath();
        ctx.moveTo(x, y - height);
        ctx.lineTo(x + TILE_SIZE/2, y + TILE_SIZE/4 - height);
        ctx.lineTo(x, y + TILE_SIZE/2 - height);
        ctx.lineTo(x - TILE_SIZE/2, y + TILE_SIZE/4 - height);
        ctx.closePath();
        ctx.fill();
        ctx.stroke(); // Outline

        // Side Faces
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.moveTo(x - TILE_SIZE/2, y + TILE_SIZE/4 - height);
        ctx.lineTo(x, y + TILE_SIZE/2 - height);
        ctx.lineTo(x, y + TILE_SIZE/2);
        ctx.lineTo(x - TILE_SIZE/2, y + TILE_SIZE/4);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(x, y + TILE_SIZE/2 - height);
        ctx.lineTo(x + TILE_SIZE/2, y + TILE_SIZE/4 - height);
        ctx.lineTo(x + TILE_SIZE/2, y + TILE_SIZE/4);
        ctx.lineTo(x, y + TILE_SIZE/2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Structure
        if (tile.structure) {
            this.drawEntity(ctx, x, y - height - 10, STRUCTURES[tile.structure.type].sym, '#d8dee9');
        }

        // Unit
        if (tile.unit) {
            const u = tile.unit;
            const owner = this.gameState.players.find(p => p.id === u.ownerId);
            this.drawEntity(ctx, x, y - height - 15, UNITS[u.type].sym, owner.color, true);
        }
    },

    drawEntity: function(ctx, x, y, symbol, color, isUnit = false) {
        ctx.save();
        ctx.translate(x, y);
        
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        ctx.ellipse(0, 10, 10, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        if (isUnit) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.stroke();
        } else {
            ctx.fillStyle = '#4c566a';
            ctx.fillRect(-8, -8, 16, 16);
        }

        ctx.fillStyle = '#fff';
        ctx.font = '10px Lato';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(symbol, 0, 0);

        ctx.restore();
    },

    drawIsoRect: function(ctx, x, y, size) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + size/2, y + size/4);
        ctx.lineTo(x, y + size/2);
        ctx.lineTo(x - size/2, y + size/4);
        ctx.closePath();
        ctx.stroke();
    },
    
    leaveLobby: function() {
        location.reload(); 
    }
};

window.onload = () => gameApp.init();

</script>
</body>
</html>